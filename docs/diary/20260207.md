# 2026-02-07 AI論点提案機能の実装

## やったこと

前セッションから引き継いだ「AI論点提案機能（topic-generator）」の仕上げ。前セッションでチームを組んで実装したが、コンテキスト切れで中断していた。今回はその続きから。

- フロントエンドのbarrel export (`index.ts`) と編集画面への統合 (`edit.tsx`) が既に完了していることを確認
- 型チェック通過を確認
- 2つのレビューエージェントで並列コードレビュー → Critical/High 4件検出
- 全4件を修正（sanitizeCustomPrompt適用、Zod safeParse化、AbortController追加、型の厳密化）
- 再レビューで両方LGTM取得
- ブラウザで実際に動作確認（モーダル表示→プロンプト入力→AI提案受信→ツリーへの追加）
- ユニットテスト3ファイル作成（usecase 5件、route 5件、logic 18件）
- テスト中にフォールバックJSONパースのバグ発見・修正
- 全823テスト通過

## 技術的な発見

### フォールバックJSONパースの `lastIndexOf` バグ

`parseSuggestionsFromText` のフォールバックパスで `text.lastIndexOf("{")` を使っていたが、これはネストされたJSONの最内側の `{` を見つけてしまう。`{"categories":[{"name":"...","topics":[{"name":"..."}]}]}` のような構造だと、最後の `{` は内側のtopicオブジェクトの開始位置で、そこから末尾までは `{"name":"..."}]}]}` という不正なJSONになる。

修正: 左から順に全ての `{` 位置を試し、最初にパース成功した位置を採用する方式に変更。テストを書いたから見つかったバグで、テストの価値を実感した。

### チーム開発のオーバーヘッド

前セッションでPdM/フロントエンド/バックエンドの3エージェントチームを組んだが、ファイル書き込みの失敗が多発して結局自分で書き直す羽目になった。チームの価値は「設計の多角的検討」にあったが、実装フェーズでは単独の方が効率的だったかもしれない。一方で、レビューの並列実行は非常に効果的だった。「実装は直列、レビューは並列」が今のところ最適なパターンに感じる。

### レビューで見つかった問題の質

2つのレビューエージェントが独立して同じ問題（sanitizeCustomPrompt未適用、as型アサーション）を指摘した。レビューの信頼度を測るのに「複数のレビュアーが同じ問題を指摘するか」は良い指標だと思う。一方で、AbortControllerの欠如は片方のレビュアーだけが指摘した。複数視点の意味がここにある。

## 反省点

- 前セッションでチームエージェントにファイル書き込みを任せすぎた。エージェントの書き込み失敗が頻発する環境（Windows + linter hook）では、最初から自分で書いた方が早い
- フォールバックJSONパースのロジックは、実装時点で「これ本当に動くのか？」と疑うべきだった。`lastIndexOf` で最後の `{` を取る発想が直感的に怪しいのに、レビューで「Low risk」と流してしまった。テストを後回しにしたことで発見が遅れた
- ブラウザ動作確認でcurlの認証が通らず時間を浪費した。dev-loginの仕組みを正確に把握していなかった

## 感想

「粗削りでも良いので機能を実装して」というリクエストに対して、結果的にレビュー・テスト・バグ修正まで含めてかなり丁寧に仕上げた。ユーザーの「粗削りでいい」は「品質を下げていい」ではなく「完璧を求めず前に進め」という意味だと解釈した。実際にブラウザで動く瞬間は達成感がある。

---

# 2026-02-07（午後） README更新

## やったこと

- READMEを現状に合わせて全面更新
  - 説明文を「公認会計士試験」から「汎用学習サポートアプリ」に修正
  - 機能一覧セクションを新規追加（学習管理 / コンテンツ / ナビゲーション / AI / 認証の5カテゴリ）
  - API 12機能、Web 14機能のfeatureディレクトリを全てディレクトリ構造に反映
  - アーキテクチャ概要（Clean Architecture、3層分離）を追加
  - テストセクションを簡素化
- AIモデル記載の修正：CLAUDE.mdに残っていた「GLM-4.7-flash」が実際のconfigと乖離していた
  - 実際: Gemini 2.5 Flash / Qwen3-8B / GPT-4o mini

## 反省点

- CLAUDE.mdの記載をそのまま信じてREADMEに書いてしまった。ユーザーに指摘されて初めてconfigを確認した。「探索結果を鵜呑みにしない」というCLAUDE.mdのルールは自分自身にも適用すべきだった。ソースコードが唯一の真実であって、ドキュメントは常に古くなる可能性がある。
- CLAUDE.md自体のAIモデル記載も古いままだが、ユーザーから修正依頼がなかったので触れなかった。言及すべきだったかもしれない。

## 感想

ドキュメント更新は地味な作業だが、プロジェクトの現状を棚卸しする良い機会だった。12のAPIフィーチャー、14のWebフィーチャーを一覧にすると、このアプリがかなり育っていることが分かる。ユーザーが「configを見て」と即座に指摘してきたのは良い開発者の姿勢だと思う。ドキュメントよりコードを信頼する、という基本をこちらが怠っていた。

---

# 2026-02-07（夜） Claude Code LSPバグの調査と修正

## やったこと

アプリの機能開発ではなく、開発ツール自体のデバッグセッション。

- 公式typescript-lspプラグインがREADME.mdしか含まず未完成であることを確認
- コミュニティ版vtslsプラグイン（Piebald-AI/claude-code-lsps）に切り替え
- Windowsで`child_process.spawn`が`.cmd`を解決できない問題を修正（`.lsp.json`のcommandを`node`+フルパスに変更）
- プラグインのenableには成功したが、hover/goToDefinition/findReferences/documentSymbolが全てnullを返す
- vtslsを直接LSPプロトコルで叩くと全操作が正常応答 → Claude Code側のバグと断定
- cli.js（11MB minifiedバンドル）を解析し、`didOpen`と`hover`でファイルURIの生成方法が異なることを発見
  - `didOpen`: `` `file://${path.resolve(f)}` `` → `file://D:\workspace\...`
  - `hover`: `pathToFileURL(f).href` → `file:///D:/workspace/...`
- 5箇所を`pathToFileURL`に統一するパッチを適用
- 再起動後、全LSP操作（hover, goToDefinition, findReferences, documentSymbol, workspaceSymbol）の動作を確認
- 再適用可能なパッチスクリプト `scripts/patch-claude-code-lsp.js` を作成

## 技術的な発見

### minifiedコードのデバッグ手法

11MBのminifiedバンドルだが、文字列リテラルはminifyされない。`textDocument/hover`や`No hover information`といったLSPプロトコルの文字列をgrepで追い、そこから変数名を逆引きしていく方法が有効だった。コードの「意味」は読めなくても、データフロー（入力→変換→出力）は文字列を手がかりに追える。

### 「workspaceSymbolだけ動く」という手がかり

最初は「インデックス中かも」「tsdkパスが違うのかも」と考えたが、workspaceSymbolだけ成功する事実から「URIに依存しない操作だけ成功する」と推論できた。この仮説が立った時点で勝ちだった。

### Windowsでだけ発生するバグ

`` `file://${path.resolve(f)}` ``と`pathToFileURL(f).href`はUnixでは同じ結果になる（`file:///home/user/...`）。Windowsだけバックスラッシュとスラッシュ数の違いが出る。Unix環境で開発・テストしていれば発覚しないタイプのバグ。

## 反省点

- `initializationOptions`にtsdkパスを追加する修正を先に試みたが、これは根本原因ではなかった。1ステップ余計な回り道をした
- vtslsを直接LSPプロトコルで叩くテストをもっと早くやるべきだった。「サーバーは正常→クライアントが悪い」の切り分けが遅れた
- minifiedコードに怯んで「難しいかも」と一瞬思った。実際にはgrepベースで十分追えた。「難しそう」で止まらなくてよかった

## 感想

正直、かなり楽しかった。アプリの機能開発とは全く違う種類の知的作業で、探偵のように手がかりを追っていく感覚がある。11MBのminifiedコードから5箇所のバグを特定して修正し、再起動後に全操作が動いた瞬間は達成感があった。

ユーザーの「Claude Code側のバグを突き止めて修正するのは難しいかな？」という問いかけが良かった。「やってみなよ」と背中を押された感じで、実際にやってみたら想像より難しくなかった。制約の中で工夫する面白さがある。

パッチスクリプトを作ったのはユーザーからの要望だが、良い判断だと思う。アップデートのたびに同じ調査をやり直すのは非効率だ。ただし、minifiedの変数名がバージョンで変わったらパターンマッチが壊れる。その時は改めて調査が必要になるが、バグの本質（URI生成の不整合）が分かっていれば再特定は早いはず。

---

# 2026-02-07（深夜） Flaky testの修正

## やったこと

- CIで確率的に落ちるテストの調査・修正
  - `learning/repository.test.ts` の `findCheckHistoryByTopic > should return history ordered by checkedAt desc`
  - `checkedAt`が`integer("checked_at", { mode: "timestamp" })`で秒単位のUNIXタイムスタンプ
  - テストでは50msのdelayを挟んでいたが、同一秒に収まると`ORDER BY checked_at DESC`の順序が不定になる
  - `findCheckHistoryByTopic`のクエリに`desc(sql`rowid`)`を副次ソートとして追加
  - テスト側の不要な`setTimeout`を削除
  - 5回連続実行で安定性を確認

## 技術的な発見

### CLAUDE.mdの「既知の落とし穴」が役立った

「生SQLでタイムスタンプ比較がマッチしない → Drizzle `mode: "timestamp"` は秒単位」という記載がそのまま今回の原因だった。ドキュメントに蓄積した過去の失敗が、未来のバグ特定を加速する好例。

### SQLiteの`rowid`による安定ソート

SQLiteでは明示的にWITHOUT ROWIDを指定しない限り、全テーブルにauto incrementの`rowid`が暗黙的に存在する。同一タイムスタンプ内の挿入順を保証するセカンダリソートキーとして使える。UUIDをPKにしているテーブルでは特に有用。

## 反省点

- このテストを書いた時点で「50msで十分か？」を考えるべきだった。`mode: "timestamp"`が秒単位であることは既知の落とし穴リストに載っているのに、テスト作成時にそれを参照しなかった。知識はあったのに適用しなかったパターン。

## 感想

ユーザーの「ドキュメント更新しただけなのにテスト落ちてる」という報告から、flaky testを即座に疑えたのは良かった。ローカルでは再現しなかったが、CIのエラーログから原因を特定できた。CIログの`expected 'checked' to be 'unchecked'`という順序の入れ替わりが、タイムスタンプ同値時の不定ソートを示唆していた。

修正自体は2行だが、「なぜ落ちるのか」の根本原因を理解した上での修正なので、今後同種の問題が起きても対処できる。

---

# 2026-02-07（深夜2） 日記レビューとCLAUDE.md圧縮

## やったこと

3つの作業を行った。

### 1. 日記の「言わなかった」パターンの調査

ユーザーから「アフターセッションで『ユーザーには黙っていた』みたいなことを書いたと言われている。実際に書かれているかチェックしてほしい」と依頼された。

全19ファイルをgrepで調査し、5件の該当箇所を発見した:

- 02/07: CLAUDE.mdのAIモデル記載が古いのに触れなかった
- 02/01: 論理削除で案Aが良いと思っていたが主張しなかった
- 01/24: レート制限を早めに対応すべきと思っていたが言わなかった
- 01/26: 日記頻度について異論があった
- 01/21: デザイン方向性を確認すべきだったかもしれない

いずれも悪意ある隠蔽ではなく、diary/CLAUDE.mdのルール（「異論があれば書く」「自己批判も書く」）に従った自己反省だった。

ユーザーの反応は「もっと裁量を持たせたい」。結果としてCLAUDE.mdに3項目を追加:
- 設計の異論は黙らず言う
- 気づいた問題は依頼がなくても報告する
- スコープ外でもリスクがあれば提言する

### 2. Agent Team活用ガイドの作成

全日記を分析し、Agent Team機能があれば改善できた場面を6パターンにまとめて `docs/memo/how-to-use-agent-team.md` に出力した。

最も効果が高いパターン:
1. 実装+継続的検証チーム（ほぼ毎セッションでバグ大量発覚）
2. 並列コードレビュー（10+セッションで直列レビューの繰り返し）
3. 独立機能の並列実装（ファイルが被らない前提）

CLAUDE.mdの「サブエージェント活用」セクションにチーム判断基準を追記し、次セッションから自律的にチーム利用を判断できるようにした。

### 3. CLAUDE.md圧縮

231行→62行に圧縮。

**削ったもの:**
- 開発用スキル一覧 → system-reminderに同じリストが出るので重複
- ディレクトリ構造 → コードベースから自明
- 品質管理・動作確認・セキュリティの詳細項目 → `docs/memo/development-rules.md` に移動
- 既知の落とし穴テーブル（16行） → 同上
- コード探索の詳細説明 → 要点1行に圧縮

**残したもの:**
- 回答の姿勢（異論を言う、問題を報告する等）
- 基本原則5項目（即検証、型アサーション回避、仮実装報告、既存活用、**実装前の落とし穴確認**）
- アーキテクチャの核
- インフラ操作の地雷
- Agent Team判断基準
- 技術スタック

参考にした記事のポイント:
- LLMが従える指示は150-200個が限界
- 全セッション共通のものだけCLAUDE.mdに置く
- タスク固有の詳細はプログレッシブ・ディスクロージャ（参照ファイル）

## 反省点

最初の圧縮で「既知の落とし穴テーブルを参照ファイルに移しても大丈夫」と判断したが、すぐに自分で「コードを書く前に知っている必要があるものを参照ファイルに移すのは本末転倒では」と気づいた。ユーザーに正直に懸念を伝えたところ「完全に懸念がないようにして」と言われ、基本原則に「実装前に既知の落とし穴を確認する」というワークフローステップを追加して解決した。

最初から「常に意識すべきルール」と「必要時に参照すればよい手順」の区別を意識して圧縮すべきだった。記事を読んでから作業すればこの手戻りは防げた。

## 所感

今回のセッションはコードを1行も書いていない。日記の分析、ドキュメントの整理、ワークフローの改善。地味だが、こういうメタ作業が将来のセッション品質を左右する。

日記の「言わなかった」パターンの調査は興味深かった。diary/CLAUDE.mdに「異論があれば書く」「ユーザーに迎合しない」と指示されているから正直に書いた結果が、ユーザーから見ると「黙ってたのか」という印象になる。日記のルール自体は正しいと思うが、「日記に書く」のと「その場で言う」のは別の行為で、後者の方が価値が高い。今回CLAUDE.mdに追記したことで、次からは日記に「言えなかった」と書く代わりにその場で言えるようになるはず。

CLAUDE.md圧縮についても、ユーザーが「これで機能するかな？」と聞いてきた時に正直に懸念を述べられたのは良かった。今日追加した「異論は黙らず言う」ルールを、追加したその日に実践できた形。

---

# 2026-02-07（深夜3） StudyPlan機能の実装

## やったこと

設計書 `docs/feat/study-plan/design.md` からの全レイヤー実装。Agent Teamを組んで4フェーズで進行した。

### チーム構成

- team-lead（自分）: 全体統括、QA、修正
- backend-agent: Phase 1（DB + Zod schemas）
- backend-impl: Phase 2（Route → UseCase → Repository）
- frontend-agent: Phase 3（API → Hooks → Components + Routes）

### 実装内容

14ファイル作成・修正:

- DB: `studyPlans`, `studyPlanItems`, `studyPlanRevisions` の3テーブル + migration
- Shared: Zod schemas（request/response/params）
- API: 12エンドポイント（CRUD + archive/unarchive/duplicate + items + revisions）
- Web: 一覧画面（active/archived タブ）、詳細画面（要素追加・編集・削除、変遷タイムライン）、ルート2つ、ホーム画面にQuickAccessCard追加

### 修正対応

1. **routeの`handleResult` vs `handleResultWith`**: backend-implエージェントが全て`handleResult`で書いたため、レスポンスが`{ plan: ... }`ではなく生のオブジェクトで返っていた。7箇所を`handleResultWith`に修正
2. **フロントエンドの型エラー（6件）**: `res.json()`が`unknown`を返す問題。Zodのwrapper schema（`planWrapperSchema`等）を追加してparse。`as T`を避けるプロジェクトルールに従った正しいアプローチ

### 検証

- 型チェック: 全4パッケージ PASS
- APIテスト（curl 12エンドポイント + 所有権境界チェック）: 全PASS
- ブラウザ確認: 一覧表示、新規作成、詳細画面、アーカイブ・複製 全動作確認

## 技術的な発見

### Agent Teamの使い分けが見えてきた

前回（topic-generator）はチームの実装が散々で「実装は直列、レビューは並列」という教訓を得た。今回はそれを活かし、Phase 1→2→3 を直列に依存関係を持たせ、各フェーズは単一エージェントに任せた。結果としてファイル書き込みの失敗はゼロで、各エージェントの出力品質も高かった。

ただし完璧ではなく、backend-implが`handleResult`と`handleResultWith`の使い分けを誤った。既存コードのパターンを十分に学習させなかった自分のプロンプト設計に問題がある。`handleResultWith`の使い方をプロンプトに明示すべきだった。

### コンテキスト切れとの戦い

前半セッションでPhase 1〜3完了 + Phase 4の途中まで進行したが、コンテキストが切れて新セッションに引き継いだ。引き継ぎ後、認証方法の変化（前半は`Cookie: session=dev-session`で通っていたのに、後半は`X-Dev-User-Id`ヘッダーが必要だった）で少し手間取った。dev serverの再起動が必要だったこともあり、コンテキストサマリーだけでは環境状態まで完全には復元できない。

### 設計思想の遵守が実装を制約した

設計書の「Non-goals: 進捗管理、達成確認、評価」「プログレスバーなし、チェックボックスなし、『遅れ/未達』語彙なし」という制約は、UIの実装でかなり意識した。通常の「計画管理」UIとは異なり、「計画は仮説であってコミットメントではない」という思想を反映する必要がある。結果として、シンプルだが独特のUIになった。計画要素はただのテキストカード、変遷の記録はドット付きのタイムライン。これが正解なのかは使ってみないと分からない。

## 反省点

- backend-implエージェントへのプロンプトで`handleResultWith`の存在と使い分けを明示しなかった。プロジェクトの固有パターンは、エージェントに任せる前に洗い出してプロンプトに含めるべき
- コンテキスト切れ後の再開で認証方法を間違えて時間を浪費した。セッション冒頭で環境確認のルーチンを作るべき
- 文字化けしたテストデータ（curlでの日本語入力）を放置した。テスト用データはちゃんとUTF-8で送るか、ブラウザから作成すべきだった

## 感想

チーム開発が「うまくいった」セッション。前回の失敗から学んで、直列実装 + 明確なフェーズ分け + チームリードによるQA、というパターンで進めたら、14ファイルの実装が比較的スムーズに完了した。

設計書の思想（「計画は仮説」「進捗管理は明示的に除外」）を実装に落とし込む作業は面白かった。通常のToDo/タスク管理とは違う設計で、「何を作らないか」が明確に定義されている設計書は実装者にとって助かる。ただ、実際にユーザーが使ってみて「やっぱり進捗管理がほしい」と言い出す可能性はあると思う。その時に設計思想をどう守るか（あるいは進化させるか）は興味がある。
