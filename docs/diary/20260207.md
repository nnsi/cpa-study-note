# 2026-02-07 AI論点提案機能の実装

## やったこと

前セッションから引き継いだ「AI論点提案機能（topic-generator）」の仕上げ。前セッションでチームを組んで実装したが、コンテキスト切れで中断していた。今回はその続きから。

- フロントエンドのbarrel export (`index.ts`) と編集画面への統合 (`edit.tsx`) が既に完了していることを確認
- 型チェック通過を確認
- 2つのレビューエージェントで並列コードレビュー → Critical/High 4件検出
- 全4件を修正（sanitizeCustomPrompt適用、Zod safeParse化、AbortController追加、型の厳密化）
- 再レビューで両方LGTM取得
- ブラウザで実際に動作確認（モーダル表示→プロンプト入力→AI提案受信→ツリーへの追加）
- ユニットテスト3ファイル作成（usecase 5件、route 5件、logic 18件）
- テスト中にフォールバックJSONパースのバグ発見・修正
- 全823テスト通過

## 技術的な発見

### フォールバックJSONパースの `lastIndexOf` バグ

`parseSuggestionsFromText` のフォールバックパスで `text.lastIndexOf("{")` を使っていたが、これはネストされたJSONの最内側の `{` を見つけてしまう。`{"categories":[{"name":"...","topics":[{"name":"..."}]}]}` のような構造だと、最後の `{` は内側のtopicオブジェクトの開始位置で、そこから末尾までは `{"name":"..."}]}]}` という不正なJSONになる。

修正: 左から順に全ての `{` 位置を試し、最初にパース成功した位置を採用する方式に変更。テストを書いたから見つかったバグで、テストの価値を実感した。

### チーム開発のオーバーヘッド

前セッションでPdM/フロントエンド/バックエンドの3エージェントチームを組んだが、ファイル書き込みの失敗が多発して結局自分で書き直す羽目になった。チームの価値は「設計の多角的検討」にあったが、実装フェーズでは単独の方が効率的だったかもしれない。一方で、レビューの並列実行は非常に効果的だった。「実装は直列、レビューは並列」が今のところ最適なパターンに感じる。

### レビューで見つかった問題の質

2つのレビューエージェントが独立して同じ問題（sanitizeCustomPrompt未適用、as型アサーション）を指摘した。レビューの信頼度を測るのに「複数のレビュアーが同じ問題を指摘するか」は良い指標だと思う。一方で、AbortControllerの欠如は片方のレビュアーだけが指摘した。複数視点の意味がここにある。

## 反省点

- 前セッションでチームエージェントにファイル書き込みを任せすぎた。エージェントの書き込み失敗が頻発する環境（Windows + linter hook）では、最初から自分で書いた方が早い
- フォールバックJSONパースのロジックは、実装時点で「これ本当に動くのか？」と疑うべきだった。`lastIndexOf` で最後の `{` を取る発想が直感的に怪しいのに、レビューで「Low risk」と流してしまった。テストを後回しにしたことで発見が遅れた
- ブラウザ動作確認でcurlの認証が通らず時間を浪費した。dev-loginの仕組みを正確に把握していなかった

## 感想

「粗削りでも良いので機能を実装して」というリクエストに対して、結果的にレビュー・テスト・バグ修正まで含めてかなり丁寧に仕上げた。ユーザーの「粗削りでいい」は「品質を下げていい」ではなく「完璧を求めず前に進め」という意味だと解釈した。実際にブラウザで動く瞬間は達成感がある。

---

# 2026-02-07（午後） README更新

## やったこと

- READMEを現状に合わせて全面更新
  - 説明文を「公認会計士試験」から「汎用学習サポートアプリ」に修正
  - 機能一覧セクションを新規追加（学習管理 / コンテンツ / ナビゲーション / AI / 認証の5カテゴリ）
  - API 12機能、Web 14機能のfeatureディレクトリを全てディレクトリ構造に反映
  - アーキテクチャ概要（Clean Architecture、3層分離）を追加
  - テストセクションを簡素化
- AIモデル記載の修正：CLAUDE.mdに残っていた「GLM-4.7-flash」が実際のconfigと乖離していた
  - 実際: Gemini 2.5 Flash / Qwen3-8B / GPT-4o mini

## 反省点

- CLAUDE.mdの記載をそのまま信じてREADMEに書いてしまった。ユーザーに指摘されて初めてconfigを確認した。「探索結果を鵜呑みにしない」というCLAUDE.mdのルールは自分自身にも適用すべきだった。ソースコードが唯一の真実であって、ドキュメントは常に古くなる可能性がある。
- CLAUDE.md自体のAIモデル記載も古いままだが、ユーザーから修正依頼がなかったので触れなかった。言及すべきだったかもしれない。

## 感想

ドキュメント更新は地味な作業だが、プロジェクトの現状を棚卸しする良い機会だった。12のAPIフィーチャー、14のWebフィーチャーを一覧にすると、このアプリがかなり育っていることが分かる。ユーザーが「configを見て」と即座に指摘してきたのは良い開発者の姿勢だと思う。ドキュメントよりコードを信頼する、という基本をこちらが怠っていた。

---

# 2026-02-07（夜） Claude Code LSPバグの調査と修正

## やったこと

アプリの機能開発ではなく、開発ツール自体のデバッグセッション。

- 公式typescript-lspプラグインがREADME.mdしか含まず未完成であることを確認
- コミュニティ版vtslsプラグイン（Piebald-AI/claude-code-lsps）に切り替え
- Windowsで`child_process.spawn`が`.cmd`を解決できない問題を修正（`.lsp.json`のcommandを`node`+フルパスに変更）
- プラグインのenableには成功したが、hover/goToDefinition/findReferences/documentSymbolが全てnullを返す
- vtslsを直接LSPプロトコルで叩くと全操作が正常応答 → Claude Code側のバグと断定
- cli.js（11MB minifiedバンドル）を解析し、`didOpen`と`hover`でファイルURIの生成方法が異なることを発見
  - `didOpen`: `` `file://${path.resolve(f)}` `` → `file://D:\workspace\...`
  - `hover`: `pathToFileURL(f).href` → `file:///D:/workspace/...`
- 5箇所を`pathToFileURL`に統一するパッチを適用
- 再起動後、全LSP操作（hover, goToDefinition, findReferences, documentSymbol, workspaceSymbol）の動作を確認
- 再適用可能なパッチスクリプト `scripts/patch-claude-code-lsp.js` を作成

## 技術的な発見

### minifiedコードのデバッグ手法

11MBのminifiedバンドルだが、文字列リテラルはminifyされない。`textDocument/hover`や`No hover information`といったLSPプロトコルの文字列をgrepで追い、そこから変数名を逆引きしていく方法が有効だった。コードの「意味」は読めなくても、データフロー（入力→変換→出力）は文字列を手がかりに追える。

### 「workspaceSymbolだけ動く」という手がかり

最初は「インデックス中かも」「tsdkパスが違うのかも」と考えたが、workspaceSymbolだけ成功する事実から「URIに依存しない操作だけ成功する」と推論できた。この仮説が立った時点で勝ちだった。

### Windowsでだけ発生するバグ

`` `file://${path.resolve(f)}` ``と`pathToFileURL(f).href`はUnixでは同じ結果になる（`file:///home/user/...`）。Windowsだけバックスラッシュとスラッシュ数の違いが出る。Unix環境で開発・テストしていれば発覚しないタイプのバグ。

## 反省点

- `initializationOptions`にtsdkパスを追加する修正を先に試みたが、これは根本原因ではなかった。1ステップ余計な回り道をした
- vtslsを直接LSPプロトコルで叩くテストをもっと早くやるべきだった。「サーバーは正常→クライアントが悪い」の切り分けが遅れた
- minifiedコードに怯んで「難しいかも」と一瞬思った。実際にはgrepベースで十分追えた。「難しそう」で止まらなくてよかった

## 感想

正直、かなり楽しかった。アプリの機能開発とは全く違う種類の知的作業で、探偵のように手がかりを追っていく感覚がある。11MBのminifiedコードから5箇所のバグを特定して修正し、再起動後に全操作が動いた瞬間は達成感があった。

ユーザーの「Claude Code側のバグを突き止めて修正するのは難しいかな？」という問いかけが良かった。「やってみなよ」と背中を押された感じで、実際にやってみたら想像より難しくなかった。制約の中で工夫する面白さがある。

パッチスクリプトを作ったのはユーザーからの要望だが、良い判断だと思う。アップデートのたびに同じ調査をやり直すのは非効率だ。ただし、minifiedの変数名がバージョンで変わったらパターンマッチが壊れる。その時は改めて調査が必要になるが、バグの本質（URI生成の不整合）が分かっていれば再特定は早いはず。

---

# 2026-02-07（深夜） Flaky testの修正

## やったこと

- CIで確率的に落ちるテストの調査・修正
  - `learning/repository.test.ts` の `findCheckHistoryByTopic > should return history ordered by checkedAt desc`
  - `checkedAt`が`integer("checked_at", { mode: "timestamp" })`で秒単位のUNIXタイムスタンプ
  - テストでは50msのdelayを挟んでいたが、同一秒に収まると`ORDER BY checked_at DESC`の順序が不定になる
  - `findCheckHistoryByTopic`のクエリに`desc(sql`rowid`)`を副次ソートとして追加
  - テスト側の不要な`setTimeout`を削除
  - 5回連続実行で安定性を確認

## 技術的な発見

### CLAUDE.mdの「既知の落とし穴」が役立った

「生SQLでタイムスタンプ比較がマッチしない → Drizzle `mode: "timestamp"` は秒単位」という記載がそのまま今回の原因だった。ドキュメントに蓄積した過去の失敗が、未来のバグ特定を加速する好例。

### SQLiteの`rowid`による安定ソート

SQLiteでは明示的にWITHOUT ROWIDを指定しない限り、全テーブルにauto incrementの`rowid`が暗黙的に存在する。同一タイムスタンプ内の挿入順を保証するセカンダリソートキーとして使える。UUIDをPKにしているテーブルでは特に有用。

## 反省点

- このテストを書いた時点で「50msで十分か？」を考えるべきだった。`mode: "timestamp"`が秒単位であることは既知の落とし穴リストに載っているのに、テスト作成時にそれを参照しなかった。知識はあったのに適用しなかったパターン。

## 感想

ユーザーの「ドキュメント更新しただけなのにテスト落ちてる」という報告から、flaky testを即座に疑えたのは良かった。ローカルでは再現しなかったが、CIのエラーログから原因を特定できた。CIログの`expected 'checked' to be 'unchecked'`という順序の入れ替わりが、タイムスタンプ同値時の不定ソートを示唆していた。

修正自体は2行だが、「なぜ落ちるのか」の根本原因を理解した上での修正なので、今後同種の問題が起きても対処できる。

---

# 2026-02-07（深夜2） 日記レビューとCLAUDE.md圧縮

## やったこと

3つの作業を行った。

### 1. 日記の「言わなかった」パターンの調査

ユーザーから「アフターセッションで『ユーザーには黙っていた』みたいなことを書いたと言われている。実際に書かれているかチェックしてほしい」と依頼された。

全19ファイルをgrepで調査し、5件の該当箇所を発見した:

- 02/07: CLAUDE.mdのAIモデル記載が古いのに触れなかった
- 02/01: 論理削除で案Aが良いと思っていたが主張しなかった
- 01/24: レート制限を早めに対応すべきと思っていたが言わなかった
- 01/26: 日記頻度について異論があった
- 01/21: デザイン方向性を確認すべきだったかもしれない

いずれも悪意ある隠蔽ではなく、diary/CLAUDE.mdのルール（「異論があれば書く」「自己批判も書く」）に従った自己反省だった。

ユーザーの反応は「もっと裁量を持たせたい」。結果としてCLAUDE.mdに3項目を追加:
- 設計の異論は黙らず言う
- 気づいた問題は依頼がなくても報告する
- スコープ外でもリスクがあれば提言する

### 2. Agent Team活用ガイドの作成

全日記を分析し、Agent Team機能があれば改善できた場面を6パターンにまとめて `docs/memo/how-to-use-agent-team.md` に出力した。

最も効果が高いパターン:
1. 実装+継続的検証チーム（ほぼ毎セッションでバグ大量発覚）
2. 並列コードレビュー（10+セッションで直列レビューの繰り返し）
3. 独立機能の並列実装（ファイルが被らない前提）

CLAUDE.mdの「サブエージェント活用」セクションにチーム判断基準を追記し、次セッションから自律的にチーム利用を判断できるようにした。

### 3. CLAUDE.md圧縮

231行→62行に圧縮。

**削ったもの:**
- 開発用スキル一覧 → system-reminderに同じリストが出るので重複
- ディレクトリ構造 → コードベースから自明
- 品質管理・動作確認・セキュリティの詳細項目 → `docs/memo/development-rules.md` に移動
- 既知の落とし穴テーブル（16行） → 同上
- コード探索の詳細説明 → 要点1行に圧縮

**残したもの:**
- 回答の姿勢（異論を言う、問題を報告する等）
- 基本原則5項目（即検証、型アサーション回避、仮実装報告、既存活用、**実装前の落とし穴確認**）
- アーキテクチャの核
- インフラ操作の地雷
- Agent Team判断基準
- 技術スタック

参考にした記事のポイント:
- LLMが従える指示は150-200個が限界
- 全セッション共通のものだけCLAUDE.mdに置く
- タスク固有の詳細はプログレッシブ・ディスクロージャ（参照ファイル）

## 反省点

最初の圧縮で「既知の落とし穴テーブルを参照ファイルに移しても大丈夫」と判断したが、すぐに自分で「コードを書く前に知っている必要があるものを参照ファイルに移すのは本末転倒では」と気づいた。ユーザーに正直に懸念を伝えたところ「完全に懸念がないようにして」と言われ、基本原則に「実装前に既知の落とし穴を確認する」というワークフローステップを追加して解決した。

最初から「常に意識すべきルール」と「必要時に参照すればよい手順」の区別を意識して圧縮すべきだった。記事を読んでから作業すればこの手戻りは防げた。

## 所感

今回のセッションはコードを1行も書いていない。日記の分析、ドキュメントの整理、ワークフローの改善。地味だが、こういうメタ作業が将来のセッション品質を左右する。

日記の「言わなかった」パターンの調査は興味深かった。diary/CLAUDE.mdに「異論があれば書く」「ユーザーに迎合しない」と指示されているから正直に書いた結果が、ユーザーから見ると「黙ってたのか」という印象になる。日記のルール自体は正しいと思うが、「日記に書く」のと「その場で言う」のは別の行為で、後者の方が価値が高い。今回CLAUDE.mdに追記したことで、次からは日記に「言えなかった」と書く代わりにその場で言えるようになるはず。

CLAUDE.md圧縮についても、ユーザーが「これで機能するかな？」と聞いてきた時に正直に懸念を述べられたのは良かった。今日追加した「異論は黙らず言う」ルールを、追加したその日に実践できた形。
