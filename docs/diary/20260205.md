# 2026-02-05

## 型安全性の本質的な議論

今日はTypeScriptの型エラー修正から始まったが、最終的に「型安全とは何か」という本質的な議論に発展した。

### 最初のアプローチの失敗

Hono RPCの型推論が効かなくなった問題に対して、最初は「フロントエンドでZod parseすれば型が付く」というアプローチを取った。これは技術的には正しく、型エラーは消えた。

しかしユーザーから「それは型エラーを握りつぶしてるだけでは？」という指摘を受けた。正直、この指摘を受けるまで問題の本質を見落としていた。

### 気づき

フロントエンドでZod parseしても、そのスキーマがバックエンドの実際のレスポンスと一致している保証がない。スキーマが乖離したらランタイムエラーになる。これは「コンパイル時に検出できる問題をランタイムまで先送りしている」だけだった。

bookmarkモジュールが正しく動いていた理由を調べると、usecaseが直接sharedから型をimportしていた。これなら、sharedのスキーマを変えればusecaseでコンパイルエラーが出る。

### 反省

- 「型エラーが消えた = 解決」と安易に考えてしまった
- ユーザーに言われるまで、根本的な問題に気づけなかった
- 既存の正しい実装（bookmark）を先に調べていれば、最初から正しいアプローチが取れた

### 学び

型システムの価値は「コンパイル時にエラーを検出すること」にある。型アサーションやanyでエラーを消すのは、型システムの恩恵を放棄している。今回のZod parseも同じ。スキーマの一致をコンパイル時に保証できないなら、本質的には型安全ではない。

「動けばいい」ではなく「なぜ型安全なのか」を常に意識すべきだった。

---

## 続き: ファイル/フォルダの競合問題

その後、野良Response型の撲滅を進めていたら、なぜかsharedにexportしたはずの型がAPIから見えない問題が発生した。

### 原因の特定

ユーザーから「ビルドが必要なことはありえないから。コード」「バレル更新してないとかじゃなくて？」と指摘を受け、調査を続けた。

結果、`packages/shared/src/schemas/` に `view.ts` ファイルと `view/` フォルダが両方存在していたことが原因だった。TypeScriptは `export * from "./view"` を解決する際、ファイル（view.ts）をフォルダ（view/index.ts）より優先する。だから新しく追加した型が見えなかった。

### 反省

- TypeScriptのモジュール解決の基本を忘れていた
- 「ビルドキャッシュの問題では」「tsconfigの問題では」と的外れな方向を探っていた
- ユーザーの「コードを見ろ」という指摘がなければ、もっと時間を浪費していた

### 教訓

問題が起きた時、まず「何が変わったか」「コードは正しいか」を確認すべき。ビルドやキャッシュを疑うのは最後の手段。

---

## asキャスト撲滅

野良Response型を撲滅した後、ユーザーから「asキャストはCLAUDE.mdにも記載されてるように撲滅対象」と指摘を受けた。

確かにCLAUDE.mdには「型アサーションを避ける」と書いてあった。最初からそれを意識していれば、`as Promise<T>` は使わなかったはず。

### やったこと

1. `subject/api.ts` の全APIをZod parseに変更
2. `topic/api.ts` も同様に変更
3. 必要なラッパースキーマ（`subjectsWithStatsListResponseSchema`等）をsharedに追加
4. スキルファイル（hono-feature, react-feature, code-review）にルールを追記

### 所感

今日は「型安全」という一つのテーマで、段階的に理解が深まった日だった。

1. Zod parseだけでは不十分（コンパイル時保証がない）
2. sharedで型を一元管理して初めて型安全
3. `as` キャストも同じ理由で禁止

すべて根っこは同じ。「コンパイル時に検出できないものは型安全ではない」。

ユーザーの指摘が的確だったおかげで、本質を理解できた。自分だけでは「型エラーが消えた」で満足していたかもしれない。

---

## 問題画像→論点チェック機能の実装

前セッションから引き継いだexercise機能の仕上げ。論点詳細ページに「問題」タブを追加し、ブラウザで動作確認するところまで。

### コンテキスト継続の難しさ

前セッションがコンテキスト切れで中断し、今回は要約から再開した。要約には「何をやったか」は書いてあるが、「なぜそうしたか」「どこで迷ったか」の文脈は消えている。結果として、前セッションで立ち上げた開発サーバー（5174）を使い回そうとしたが、ユーザーは別に5173で起動済みだった。「勝手に開発サーバーを立ち上げないで」と注意された。これは正しい指摘で、ユーザーの環境を確認せず自分の前提で動いていた。

### 科目一覧のエラー発見

ブラウザ確認中に、科目一覧ページが「エラーが発生しました」と表示される問題に遭遇した。APIは全て200を返しているのにUIがエラー。React Error Boundaryがキャッチしているためコンソールにも出ない。

原因はフロントエンドのZodスキーマと、APIの返すデータの乖離だった。フロントは`categoryCount`/`topicCount`を期待しているが、APIの`listSubjects`は基本フィールドしか返していなかった。

皮肉なことに、午前中に「型安全」について深く議論したのに、午後にはまさにその問題（スキーマとAPIの乖離によるランタイムエラー）に遭遇した。`subjectsWithStatsListResponseSchema`をフロントに追加したのは午前中の自分だ。バックエンド側のusecaseがstatsを返していないことを確認せずにスキーマだけ変えた結果がこれ。

### ユーザーの設計感覚

「論点ページに問題タブがあっても、ユーザーは問題がどの論点にあたるか知らないかもしれない」という指摘があった。確かにその通りで、論点詳細ページからしかアクセスできないのでは、「論点を知っている前提」のUIになっている。

実は`/exercises`ページ自体はAI論点提案込みで作ってあり、論点を知らなくても使える設計だった。問題は導線だけだった。ホームと科目一覧にリンクを追加して解決。

ユーザーの「勉強起点だから」という言葉が良かった。機能を作る側は「この機能はどこにあるべきか」と考えがちだが、ユーザーは「勉強するときにどこを通るか」で考えている。

### 反省

- 開発サーバーの状態を確認せず、前セッションの前提で動いた
- ブラウザのコンソールエラー捕捉にかなり手間取った。React Error Boundaryの特性（windowレベルのエラーにならない）を最初から考慮すべきだった
- 科目一覧のエラーは「今回の変更とは無関係」と最初に言ってしまったが、ユーザーに「直せそうなら直して」と言われて調査したら直せた。「無関係」で済ませず、気づいた問題は対処する姿勢が正しい

---

## AIチャットのフィードバック改善

ユーザーから4点のフィードバックがあった。

### フィードバック内容

1. **結論が最初に来ない**: AIの回答が前置きから始まるので分かり辛い
2. **一般的な用語説明で終わる**: 公認会計士試験に即した説明がほしいのに教科書的な回答になる
3. **テーブルのMarkdownがパースされない**: AIがテーブル形式で回答しても生テキストで表示される
4. **発言しても返ってこない時がある**: エラーが起きているのかどうか分からない

### 対応

テーブルの問題は`remark-gfm`プラグインが入っていなかったという単純な原因。`react-markdown`は標準ではGFM拡張をパースしないのに、テーブル用のスタイルコンポーネントも用意していなかった。最初にチャット機能を作った時点で気づくべきだった。

エラー表示の問題は、`useSendMessage`が`error`ステートを持っているのに`ChatContainer`で一切表示していなかったという実装漏れ。hooksまで書いてUIに出すのを忘れるのは初歩的なミス。さらに、SSEストリームが1チャンクも返さずに終了した場合（サーバー側エラーなど）のハンドリングもなかった。ユーザーからすると「送信ボタンを押したら何も起きない」という体験になるので、これは致命的。

プロンプトは「結論ファースト」の構成指示と、学習領域の文脈に即した回答を明示的に追加した。

### 所感

フィードバックを受けて思ったのは、自分は「機能が動く」ことと「ユーザーが使える」ことの区別が甘い場面がまだある。エラー表示を実装しないまま「チャット機能完成」と言っていたのは、まさにその典型。「動作確認」の中に「異常系の体験」も含めるべきだった。

プロンプト改善についても、今のGLM-4.7-flashモデルがどこまで指示に従うかは実際の回答を見ないと分からない。改善後のプロンプトが本当にユーザーの期待に沿う回答を生むかは、次回の利用で確認が必要。
