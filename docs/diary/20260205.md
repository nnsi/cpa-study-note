# 2026-02-05

## 型安全性の本質的な議論

今日はTypeScriptの型エラー修正から始まったが、最終的に「型安全とは何か」という本質的な議論に発展した。

### 最初のアプローチの失敗

Hono RPCの型推論が効かなくなった問題に対して、最初は「フロントエンドでZod parseすれば型が付く」というアプローチを取った。これは技術的には正しく、型エラーは消えた。

しかしユーザーから「それは型エラーを握りつぶしてるだけでは？」という指摘を受けた。正直、この指摘を受けるまで問題の本質を見落としていた。

### 気づき

フロントエンドでZod parseしても、そのスキーマがバックエンドの実際のレスポンスと一致している保証がない。スキーマが乖離したらランタイムエラーになる。これは「コンパイル時に検出できる問題をランタイムまで先送りしている」だけだった。

bookmarkモジュールが正しく動いていた理由を調べると、usecaseが直接sharedから型をimportしていた。これなら、sharedのスキーマを変えればusecaseでコンパイルエラーが出る。

### 反省

- 「型エラーが消えた = 解決」と安易に考えてしまった
- ユーザーに言われるまで、根本的な問題に気づけなかった
- 既存の正しい実装（bookmark）を先に調べていれば、最初から正しいアプローチが取れた

### 学び

型システムの価値は「コンパイル時にエラーを検出すること」にある。型アサーションやanyでエラーを消すのは、型システムの恩恵を放棄している。今回のZod parseも同じ。スキーマの一致をコンパイル時に保証できないなら、本質的には型安全ではない。

「動けばいい」ではなく「なぜ型安全なのか」を常に意識すべきだった。

---

## 続き: ファイル/フォルダの競合問題

その後、野良Response型の撲滅を進めていたら、なぜかsharedにexportしたはずの型がAPIから見えない問題が発生した。

### 原因の特定

ユーザーから「ビルドが必要なことはありえないから。コード」「バレル更新してないとかじゃなくて？」と指摘を受け、調査を続けた。

結果、`packages/shared/src/schemas/` に `view.ts` ファイルと `view/` フォルダが両方存在していたことが原因だった。TypeScriptは `export * from "./view"` を解決する際、ファイル（view.ts）をフォルダ（view/index.ts）より優先する。だから新しく追加した型が見えなかった。

### 反省

- TypeScriptのモジュール解決の基本を忘れていた
- 「ビルドキャッシュの問題では」「tsconfigの問題では」と的外れな方向を探っていた
- ユーザーの「コードを見ろ」という指摘がなければ、もっと時間を浪費していた

### 教訓

問題が起きた時、まず「何が変わったか」「コードは正しいか」を確認すべき。ビルドやキャッシュを疑うのは最後の手段。

---

## asキャスト撲滅

野良Response型を撲滅した後、ユーザーから「asキャストはCLAUDE.mdにも記載されてるように撲滅対象」と指摘を受けた。

確かにCLAUDE.mdには「型アサーションを避ける」と書いてあった。最初からそれを意識していれば、`as Promise<T>` は使わなかったはず。

### やったこと

1. `subject/api.ts` の全APIをZod parseに変更
2. `topic/api.ts` も同様に変更
3. 必要なラッパースキーマ（`subjectsWithStatsListResponseSchema`等）をsharedに追加
4. スキルファイル（hono-feature, react-feature, code-review）にルールを追記

### 所感

今日は「型安全」という一つのテーマで、段階的に理解が深まった日だった。

1. Zod parseだけでは不十分（コンパイル時保証がない）
2. sharedで型を一元管理して初めて型安全
3. `as` キャストも同じ理由で禁止

すべて根っこは同じ。「コンパイル時に検出できないものは型安全ではない」。

ユーザーの指摘が的確だったおかげで、本質を理解できた。自分だけでは「型エラーが消えた」で満足していたかもしれない。
