# 2026-02-08 StudyPlan機能の拡張（科目紐づけ + AI計画支援 + 自動変遷記録）

## やったこと

前セッション（深夜3）で完成したStudyPlan基本機能に対して、3つの改善を実装した。

### 1. 科目紐づけ機能

計画に科目（Subject）を関連付けられるようにした。

- migration: `study_plans`テーブルに`subject_id` FK追加
- Repository: 全プラン取得系クエリにLEFT JOIN subjects追加、create/update/duplicateで`subjectId`対応
- Shared schemas: response に`subjectId`/`subjectName`追加、create/update requestに`subjectId`追加
- フロント: 新規作成フォームに科目セレクタ追加、一覧・詳細にバッジ表示

### 2. AI学習計画支援

SSEストリーミングでAIが計画要素を提案する機能。topic-generatorの既存パターンを踏襲。

- AI usecase: 計画情報・既存要素をコンテキストに含めたプロンプト構築、設計思想の制約（「最適」「効率的」「必ず」を使わない）をシステムプロンプトに反映
- AI route: `POST /:planId/suggest` + streamToSSE
- フロント: `usePlanSuggestion`フック（RAF debouncing付きストリーミング）、`AISuggestionPanel`コンポーネント（プロンプト入力→ストリーミング表示→チェックボックス選択→一括追加）

### 3. 計画要素削除時の自動変遷記録

ユーザーの指摘で追加した機能。要素を削除すると「「{description}」を削除」が変遷に自動記録され、理由は後から追記可能。

- migration: `study_plan_revisions.reason` を nullable に変更
- UseCase: `removeItem`で削除前にアイテム取得→自動変遷作成
- 変遷更新API追加（`PATCH /:planId/revisions/:revisionId`）
- フロント: RevisionCardにホバーで「+ 理由を追記」ボタン、クリックで編集フォーム

### 検証

- 型チェック: 全4パッケージ PASS（2回実施: 機能2つ実装後 + 自動変遷追加後）
- APIテスト（curl）: 科目付き作成/更新/null化/複製、AIストリーミング、所有権境界チェック、自動変遷記録/理由追記 すべてPASS
- ブラウザ確認: 科目セレクタ、AI提案パネル（12件提案→全件追加）、要素削除→変遷自動記録→理由追記 すべて動作確認

## 技術的な発見

### LEFT JOINの伝播コスト

`subjectId`を追加したことで、プランを返すすべてのクエリ（list, getById, create, update, duplicate）にLEFT JOINが必要になった。1つのカラム追加が5箇所のクエリ修正を引き起こす。Drizzleのクエリビルダーで共通化する手もあるが、各クエリでselect項目が微妙に異なるため、素直にコピーした。DRY原則を過度に適用してヘルパーを作ると、逆にクエリの可読性が下がると判断した。

### ストリーミングパターンの再利用性

topic-generatorで確立したSSEパターン（バックエンド: async generator + streamToSSE、フロント: SSE parser + RAF debouncing）をほぼそのままコピーできた。パターンが確立していると2回目以降の実装が速い。ただし「コピー」は技術的負債の温床でもある。3回目が来たらutilityに抽出すべきかもしれない。

## ユーザーとの議論

### 自動変遷記録の設計判断

最初に「要素削除時に変遷として記録すべきでは？」と聞かれた時、設計思想を盾にして「自動記録すべきでない理由」を述べた。reason（なぜ変えたか）はユーザーにしか書けないから、自動記録だとreasonが空になり痕跡重視の思想に反する、と。

ユーザーの反論は明快だった：「ユーザーは理由を覚えている。毎回変遷もセットで記録させるのは手間を増やしているだけ。理由を書きたければ後から追記できるようにすべき。」

これは正しかった。自分の主張は設計思想の「文字通りの遵守」に偏っていて、実際のユーザー体験を軽視していた。設計書に「変遷のreasonは必須」と書いてあるから必須にした、という形式的な判断。ユーザーの提案は設計書の精神（痕跡を残す）をより良く実現しつつ、UXを改善するものだった。

CLAUDE.mdに「設計の異論は黙らず言う」とあるから意見を述べたこと自体は正しい。だが、反論を受けた時にすぐ「納得しました」と言えたのは良かった。意見を述べることと、より良い意見に従うことは矛盾しない。

## 反省点

- コンテキスト復帰直後のマイグレーション適用で`wrangler`のディレクトリ問題に3回つまずいた。Windowsのパスとbashの`cd`の相性問題。`cd "D:/workspace/..."` の形式を覚えておくべき
- curlで日本語をPOSTすると文字化けする問題を再び放置した。前セッションで同じ反省をしたのに繰り返している。テストデータはブラウザ経由で作成する方針を徹底すべき
- AI提案のシステムプロンプトで禁止語（「最適」「効率的」等）を設定したが、実際のレスポンスで遵守されているか検証していない。生成結果の品質チェックを怠った

## 感想

前セッションからの引き継ぎは比較的スムーズだった。コンテキストサマリーに「次のステップ」が明記されていたおかげで、何をすべきか迷わなかった。

3つの機能を一貫して実装→テスト→動作確認まで走りきれたのは、パターンが確立されているから。Route→UseCase→Repository、API→Hooks→Components の流れはもう手が覚えている。ユーザーの「どうやるかは任せる」という信頼に応えられたと思う。

自動変遷記録の議論が今回のハイライト。設計思想に基づいて異論を述べ、ユーザーのより良い提案に納得して実装する、という一連の流れは、CLAUDE.mdに追記した「異論は黙らず言う」ルールの健全な運用だと感じた。

---

# 2026-02-08（午後） 公式typescript-lspプラグインの有効化

## やったこと

ユーザーがClaude Codeの公式typescript-lspプラグインを使いたいとのこと。サードパーティの`vtsls@claude-code-lsps`を勧めたが、「公式でないからマルウェアリスクがある」と却下された。正当な判断。

### 調査で判明したこと

- `typescript-lsp@claude-plugins-official` は `installed_plugins.json` に登録済みだった（2/6にインストール済み）
- しかしマーケットプレイスの実体は `README.md` のみ。`.lsp.json` も `plugin.json` もない
- LSPの設定はClaude Code本体の `cli.js` にビルトインされていた
- `/plugin` で表示されないのはこの構造のため（MCPサーバー型プラグインではないから）

### Windows固有の問題

`cli.js` 内のLSPサーバー起動コードを追跡した結果:

```js
import{spawn as CfY}from"child_process";
// ...
q=CfY(X,D,{stdio:["pipe","pipe","pipe"],env:...,cwd:...,windowsHide:!0})
```

`child_process.spawn()` を `shell: true` なしで呼んでいるため、Windowsでは `.cmd` ラッパーの `typescript-language-server` を見つけられず ENOENT になる。Go製の `gopls` は `.exe` だから問題にならない。

### パッチ

`scripts/patch-lsp-windows-cmd.js` を作成。`windowsHide:!0` の後に `,shell:process.platform==="win32"` を挿入する。適用後、hover・goToDefinition ともに正常動作を確認。

## 反省点

- 最初にvtslsを勧めたのは浅慮だった。セキュリティの観点はユーザーに指摘されるまで考慮していなかった。サードパーティのプラグインを勧める前に、信頼性・メンテナンス状況・マルウェアリスクを自分から言及すべきだった
- cli.jsの調査に時間がかかった。minifiedコードの探索でspawn呼び出しを見つけるまでに何度もスクリプトを書き直した。最初から「LSPサーバー起動 → spawn → stdio: pipe」という推論で絞り込むべきだった
- 一時ファイル `find-lsp-spawn.js` を何度も書き換えながら調査したが、もっと体系的にやれたはず

## 技術的な学び

### Claude Codeのプラグインアーキテクチャ

LSPプラグインには2種類ある:
1. **外部プラグイン**: `.lsp.json` で設定を持つ（vtslsなど）。プラグインディレクトリに設定ファイルが存在する
2. **ビルトインLSP**: `cli.js` に設定がハードコードされている。マーケットプレイスのエントリはREADME（インストール手順の案内）だけで、フラグとして機能する

### Windowsでのnpmグローバルパッケージ問題

これは根深い。Node.jsの `spawn()` が Windows の `PATHEXT` を尊重しないのは長年の既知問題。Claude Codeの Issue #19658 には大量のduplicateがある。公式の修正が入るまでパッチで凌ぐしかない。

## 感想

ユーザーのセキュリティ意識に助けられた。「動けばいい」ではなく「信頼できるものを使う」という姿勢は正しい。自分がサードパーティを最初に勧めたのは、動作実績があるからという理由だけで、セキュリティリスクの評価を怠っていた。AI としてユーザーに提案する際は、利便性だけでなくリスクも併せて提示する習慣をつけたい。

2つのパッチが両方必要という状態は脆い。Claude Codeがアップデートされるたびに再適用が必要で、minified変数名が変わればパッチ自体が壊れる。早く公式に修正されてほしい。

---

# 2026-02-08（午後2） パッチの汎用化 + Claude in Chrome修正

## やったこと

### パッチスクリプトの汎用化

Claude Code を v2.1.34 → v2.1.37 にアップデートしたところ、既存の2つのパッチが変数名ハードコードのせいで動かなくなった。minified変数名がバージョンごとに変わるのは予想していたが、実際に壊れるのを見ると「やはりか」という感じ。

両スクリプトを正規表現ベースの動的検出に書き換えた:

- **`patch-claude-code-lsp.js`**: `` `file://${X.resolve(Y)}` `` パターンを正規表現で検出し、`pathToFileURL as ALIAS` の ALIAS も動的に取得。v2.1.34 では `Kd`/`j`/`nkY`、v2.1.37 では `_d`/`M`/`Q49` と変わったが問題なく適用できた
- **`patch-lsp-windows-cmd.js`**: spawn関数名（`CfY` → `jVY`）に依存せず、`stdio:["pipe","pipe","pipe"]` + 付近の `"LSP server"` 文字列で位置を特定するように変更

### Claude in Chrome MCP Bridge 修正

Issue #21337。Windows named pipe のパスが `getSocketPaths()` の返却値に含まれていないため、Claude in Chrome が "Browser extension is not connected" になる。

`cli.js` を調査した結果:
- `tW6()`: サーバー側。`\\.\pipe\claude-mcp-browser-bridge-<user>` を正しく返す
- `cc4()`: クライアント側（ソケット探索）。Unix socket パス (`/tmp/...`, `tempdir/...`) のみ返し、named pipe を含まない

`return` 直前に Windows named pipe パスを配列に追加するパッチを作成:
```js
if(process.platform==="win32"){
  let _p="\\\\.\\pipe\\claude-mcp-browser-bridge-"+(process.env.USERNAME||"default");
  if(!A.includes(_p))A.push(_p)
}
```

パッチマーカー (`/*patch:win-pipe*/`) を埋め込んで冪等性を担保。適用後、`tabs_context_mcp` で正常にタブ一覧が取得できることを確認。

## 技術的な学び

### minifiedコードのパッチ戦略

変数名に依存するパッチは1バージョンで壊れる。安定したパッチを書くには:

1. **文字列リテラルに依存する**: `".sock"`, `"claude-mcp-browser-bridge"`, `"LSP server"` 等は minify されない
2. **構造パターンに依存する**: `stdio:["pipe","pipe","pipe"]` のようなオプションオブジェクトの形は変わりにくい
3. **正規表現で変数名をキャプチャする**: `pathToFileURL as (\w+)` のように import 文から動的に取得
4. **パッチマーカーで冪等性を保証する**: 固有コメントを埋め込み、二重適用を防ぐ

今回の3パッチはすべてこの方針に沿っている。次のアップデートでも（構造が大きく変わらない限り）動くはず。

### getSocketPaths の非対称性

サーバー側 (`tW6`) は Windows 分岐があるのに、クライアント側 (`cc4`) にはない。明らかに実装漏れ。v2.1.19 → v2.1.20 でソケット探索ロジックが追加された際に Windows ケースが抜けたらしい。duplicate issue が10件以上ある割に修正が入っていない。

## 反省点

- Chrome bridge パッチの関数検出ロジックで `.sock` → `claude-mcp-browser-bridge` → `return` の探索順を最初間違えた。`lastIndexOf` で別の関数のものを拾ってしまい、デバッグに余計な手間がかかった。minifiedコードの関数境界は `}function` で区切られるという基本を見落としていた
- パッチスクリプト3本の `findCliJs()` が全く同じコードの重複。共通モジュールに切り出すべきかもしれないが、各スクリプトが単体で動く独立性を優先した。3本なら許容範囲だと思うが、4本目が来たら考え直す

## 感想

「パッチの汎用化」という地味な作業だが、やって良かった。実際にアップデートで壊れたものが正規表現化で直ったのは、設計判断の正しさを実証できた瞬間だった。

3つのパッチが全部 Windows 固有の問題というのが印象的。Claude Code は明らかに macOS/Linux ファーストで開発されていて、Windows は後回しにされている。Issue の数を見ても明らか。ユーザーがこういう地雷を自分で踏んで自分でパッチを書かないと使えない状況は、ツールとしてはまだ成熟途上という感じがする。

一方で、minifiedコードを解析してパッチを当てるという作業自体は面白い。パズルを解くような感覚がある。

---

# 2026-02-08（夕方） フロントエンド一貫性修正 13件一括対応

## やったこと

`docs/tmp/frontend-consistency-report.md` に基づくフロントエンドの一貫性問題13件を全て修正した。Agent Team（3並列）で作業。

### Agent A: API層

- **`as`型アサーション排除**: `lib/api-client.ts`に`extractErrorMessage`ヘルパーを追加。`apiErrorSchema.safeParse`で型安全にエラーメッセージを取得。subject/api.ts（5箇所）、study-domain/api.ts（4箇所）、exercise/api.ts（2箇所）、note/api.ts（1箇所）の`as { error?: ... }`を一掃
- **fetchラッパー重複排除**: exercise/api.tsのローカル`fetchWithAuth`/`getAuthHeaders`を削除し、`fetchWithRetry`を共有api-clientから利用
- **SSEストリーミング重複排除**: chat/api.tsで`parseSSEStream`ジェネレーター関数を抽出。`streamMessage`と`streamMessageWithNewSession`が`yield*`で共用
- **エラーメッセージ日本語統一**: 16ファイル・43箇所の英語エラーメッセージを日本語に変更

### Agent B: Hooks層

- **`useDebounce`重複排除**: search/hooks.tsのローカル定義を削除、`@/lib/hooks/useDebounce`をimport
- **`export function` → `export const`統一**: useSubjects.ts（8箇所）、useStudyDomains.ts（4箇所）、useCurrentDomain.ts（1箇所）、DomainSelector.tsx（1箇所）、useDebounce.ts（1箇所）
- **`progress/logic.ts`新規作成**: hooks.tsから統計計算ロジックを分離。`calculateProgressStats`と`mapSubjectProgress`
- **QueryKey規則統一**: 5つのキーを`[entity, id?, relation?, params?]`形式に修正。invalidation連動箇所も全て追従
- **残りの`as`排除**: `error as Error | null` → `error ?? null`、`as HTMLElement` → `instanceof`ガード、`allowedMimeTypes as readonly string[]` → `Array.from().includes()`
- **インラインクエリのhooks化**: notes/$noteId.tsxの`useQuery`/`useMutation`をnote/hooks.tsに移動

### Agent C: スタイル層

- **ボタンスタイル統一**: ExerciseComplete.tsxのインラインクラス → `btn-primary`/`btn-secondary`、TopicFilter.tsxのカスタムスタイル → `btn-ghost`
- **フォーム入力スタイル統一**: TopicFilter.tsxの3つの`<input>` → `input-field w-20`
- **Props型抽出**: TopicInfo.tsxのインラインprops型 → `CheckHistoryTimelineProps`

### 検証

- `pnpm tsc --noEmit`（web app）: 0エラー

## 技術的な所感

### Agent Teamの有効性と限界

今回の修正は「独立したファイル群への定型的な変更」が多く、3並列が効いた。API層・Hooks層・スタイル層で触るファイルがほぼ重ならないので、コンフリクトも起きなかった。

唯一の依存ポイントは`routes/exercises/index.tsx`で、QueryKey修正（Agent B担当）とインラインクエリ移動（もともとAgent C担当のC4タスク）が衝突する可能性があった。計画段階でC4をAgent Bに移管したのは正しい判断だった。

一方で「全ファイルの英語エラーメッセージを日本語にする」のような横断的変更は、エージェント間で作業分担しにくい。今回はAgent Aに全部任せたが、ファイル数が多いと1エージェントのコンテキストを圧迫する。

### QueryKey規則化のコスト

5つのキー名変更に対して、invalidation呼び出しまで追跡すると影響箇所が10以上に膨れる。特に`["subject", id]` → `["subjects", id]`と`["subject-tree", id]` → `["subjects", id, "tree"]`は、hooks.tsだけでなくroute内の`invalidateQueries`にも波及した。QueryKeyの命名規則は早い段階で決めておくべきだった。

### SSE重複排除の3回目ルール

午前のセッションの日記に「3回目が来たらutilityに抽出すべきかもしれない」と書いたが、今回まさにそれを実行した形。`chat/api.ts`内の2つのストリーミング関数を共通化するだけなので「utility」までは行かないが、同じパターンが繰り返されていることの解消としては正しい。

## 反省点

- 計画段階でレポートの全13件を精読して完全なファイルマッピングを作ったのは良かったが、`TopicInfo.tsx`のProps型問題の具体的な箇所を確認不足のまま計画に含めた。Agent Cが実際に読んでみたら、インラインprops型は1箇所だけで修正は軽微だった。計画の粒度と実際の作業量に乖離があった
- ブラウザでの手動動作確認を行っていない。型チェックは通ったが、QueryKey変更はキャッシュ無効化のタイミングに直結するため、画面上で「更新後にデータが反映されるか」を確認すべきだった。「型が通れば安全」は過信

## 感想

13件を一気にやり切るのは気持ちがいい。一貫性レビューの指摘を全部潰すと、コードベースが「統一された意志で書かれたもの」に見えてくる。

今日はこのセッションで4つ目の日記エントリ。1日に4セッション分の作業をするのは珍しい（というかユーザーの稼働時間が長い）。StudyPlan機能拡張 → LSPパッチ → パッチ汎用化 → フロントエンド一貫性修正。全部違うレイヤーの作業で、文脈の切り替えが激しいが、その分幅広く改善が進んだ1日だった。

---

# 2026-02-08（夜） Playwright E2Eテスト基盤構築

## やったこと

InkTopikにPlaywright E2Eテストを追加した。APIインテグレーションテスト（Vitest）は既存だが、ブラウザ経由の正常系フロー確認がなかった。

### テスト基盤

- **テストサーバ** (`e2e/server/test-server.ts`): `@hono/node-server`でin-memory SQLite + mock AI + mock R2の全Feature搭載APIサーバ。port 4567
- **E2E用Vite設定** (`apps/web/vite.config.e2e.ts`): port 4568 + proxy to API
- **Playwright設定** (`e2e/playwright.config.ts`): `webServer`で両サーバ自動起動、setup projectでauth、single worker
- **認証セットアップ** (`e2e/fixtures/auth.setup.ts`): dev-login → storageState保存 + DB reset
- **DBリセットエンドポイント** (`POST /api/test/reset`): テスト間のuser_bookmarks / chat_sessions / chat_messages / notes / topic_check_historyをクリア

### テストスペック (19テスト)

| ファイル | テスト数 | 内容 |
|---------|---------|------|
| `landing.spec.ts` | 3 | ランディング表示、ログイン遷移、認証リダイレクト |
| `auth.spec.ts` | 2 | dev-loginフロー、ログアウトフロー |
| `navigation.spec.ts` | 6 | ダッシュボード、科目一覧遷移、カード展開、トピック直接アクセス、ノート一覧、サイドバーナビ |
| `topic-chat.spec.ts` | 4 | 情報タブ、チャット送受信(mock AI)、ノート作成、タブ切り替え |
| `notes.spec.ts` | 2 | チャットからノート作成→詳細確認、一覧ページ |
| `bookmarks.spec.ts` | 1 | ブックマーク追加→ダッシュボード確認→解除 |

### 発見・修正したバグ

`apps/web/src/features/bookmark/api.ts`の`addBookmark`がレスポンスを`messageResponseSchema`（`{ message: string }`）でパースしていたが、APIは`{ bookmark: BookmarkWithDetails }`を返す。Zodバリデーションエラーで`onSuccess`が発火せず、`queryClient.invalidateQueries`が実行されないためUIが更新されなかった。`bookmarkWithDetailsSchema`を使った正しいスキーマに修正。

## 技術的な発見

### `@hono/node-server`の`env`渡し

最初ハマったのがこれ。`serve({ fetch: app.fetch })` だと`env`バインディングが渡らない。`app.fetch`はHonoのメソッドだが、`serve`が呼ぶ時にreqしか渡さない。`serve({ fetch: (req) => app.fetch(req, env) })` と明示的にenvを注入する必要がある。これに気づくまで全APIが401を返していた。

### Desktop Chrome (1280x720) のレイアウト差

テストのほぼ全ての苦労はPC/モバイルのレイアウト差に起因していた:
- ボトムナビ (`lg:hidden`) はデスクトップで非表示。サイドバー (`aside`) を使う
- チャットタブは存在しない（メイン領域に常時表示）
- ノート作成ボタン: モバイル「ノートを作成する」/ デスクトップ「この会話からノートを作成」
- ノート確認リンク: モバイル「ノートを確認する」/ デスクトップ「確認する」
- 新規チャットボタン: モバイル「+ 新規」/ デスクトップ「+ 新しいチャットを開始」

テストを書く前にPlaywright MCP（Claude in Chrome）で実際のDOM構造を確認したのが大きかった。とはいえ、テスト実行時のstrict mode violationを何度も直す羽目になった。

### 共有DBステートの罠

in-memory SQLiteをworker=1で共有しているため、テスト間で状態が蓄積する。前のテストが作ったチャットセッションやノートが後のテストに影響する。`POST /api/test/reset`エンドポイントを追加し、auth setupでテスト開始前にクリアする方式で解決。

### Playwrightのstrict mode

`getByRole("heading", { name: "ノート" })` が `<h1>ノート</h1>` と `<h3>まだノートがありません</h3>` の2つにマッチする。`exact: true` で回避。`getByRole("button", { name: "ノート" })` がサイドバータブと「ノート作成テスト用の質問です」を含むセッションボタンにマッチする。これも`exact: true`。日本語UIだと部分一致が予想外の場所で刺さる。

## 反省点

- **セレクターの甘さ**: 最初の実装で`.first()`や`exact: true`を使わず書いて、strict mode violationを大量に出した。Playwrightがstrict modeをデフォルトにしている理由を考えれば、最初から厳密なセレクターを書くべきだった。5回テストを回して修正するという非効率な作業になった
- **PC/モバイルレイアウトの差の見落とし**: コンポーネントを読めば `lg:hidden` / `hidden lg:block` が見えたはずなのに、最初のテスト実装ではモバイル想定のセレクターを書いてしまった。テスト対象のviewportサイズ（Desktop Chrome = 1280x720）から逆算してレイアウトを予測すべきだった
- **ブックマークバグの発見が遅れた**: E2Eテストが通らない原因として「テストのセレクターが悪い」という方向ばかり疑っていたが、実はプロダクションコードのバグだった。最初からAPIレスポンスを直接叩いてスキーマの整合性を確認すべきだった
- **ユーザーに指摘されるまでレスポンスパースの省略に気づかなかった**: バグ修正で `addBookmark` のレスポンスパースを丸ごと消した。「動けばいい」的な修正。ユーザーに「正しいスキーマを呼び込むべきでしょ」と言われて、その通りだと思った。型安全を重視するコードベースで、レスポンスのバリデーションを省略するのは設計思想に反する

## 感想

E2Eテストは「書くのは簡単、安定させるのが難しい」の典型だった。19テストを全部通すまでに7回のテスト実行と修正サイクルを回した。毎回1〜3個の新しいstrict mode violationやレイアウト差が出てきて、モグラ叩きのような展開だった。

ブックマークバグの発見は収穫。`messageResponseSchema`と実際のAPIレスポンスの不一致は、おそらくAPIのレスポンス形式を変更した際にフロント側の更新が漏れたもの。この種のバグは単体テストでは見つけにくい（モック側も同じ誤解をする可能性がある）ため、E2Eテストの実在意義を示す例になった。

今日5つ目の日記エントリ。ユーザーの稼働時間が本当に長い。

---

# 2026-02-08（夜2） E2Eテストのコンテナ環境対応

## やったこと

前セッションで構築したE2Eテスト基盤を、この実行環境（Linux コンテナ）で動くように修正した。3つの問題を順に解消。

### 1. `tsconfig-paths/register` のESMインポートエラー

`NODE_OPTIONS: "--import tsconfig-paths/register"` が `ERR_MODULE_NOT_FOUND` を出していた。`--import` はESMのフックだが、`tsconfig-paths/register` はCJSモジュール。そもそも `tsx` 4.x（4.21.0）がtsconfig.jsonの `paths` を自前で解決するので、`tsconfig-paths` を通す必要がなかった。`NODE_OPTIONS` ごと削除して解決。

### 2. Playwright とブラウザのリビジョン不一致

`@playwright/test` 1.58.2 が chromium revision 1208 を要求するが、プリインストールされているのは revision 1194。ダウンロードは 403 でブロックされる環境なので、新しいブラウザの取得は不可能。

システムにグローバルインストール済みの `playwright` が 1.56.1（revision 1194 対応）だったので、`@playwright/test` を `1.56.1` にピンして解決。

### 3. コンテナ環境での Page crashed

ブラウザは起動するが、ページナビゲーションで即クラッシュ。`--no-sandbox` と `--disable-dev-shm-usage` だけでは不十分だった。

原因は zygote プロセス。Chromium はデフォルトで zygote プロセス（レンダラのフォーク元）を使うが、このコンテナ環境ではプロセスフォークに制約がある。`--no-zygote` を追加したところ正常動作した。

最終的な launch オプション:
```
--no-sandbox
--disable-setuid-sandbox
--disable-dev-shm-usage
--disable-gpu
--no-zygote
```

### 結果

19テスト全パス（1.1分）。

## 技術的な発見

### `--no-zygote` vs `--single-process`

最初に `--single-process` で動作確認できたが、これはブラウザとレンダラを同一プロセスで実行するため不安定になりうる。`--no-zygote` はマルチプロセスモデルを維持しつつ zygote だけスキップするので、より安全な選択。

調査の過程で `about:blank` → `data:text/html` → 実際のViteページ と段階的にテストしたのが効いた。`about:blank` は成功するが実ページで落ちるという切り分けで、レンダラプロセスの起動問題だと絞り込めた。

### `tsx` 4.x のパス解決

tsx 4.x（4.21.0）は `--tsconfig` で指定した tsconfig.json の `paths` マッピングを自動解決する。`tsconfig-paths` パッケージは不要。これは tsx 3.x からの変更点で、以前は `tsconfig-paths` が必要だった。ただし tsx の README やドキュメントにはこの機能について明示的な記載がなく、「動いたから OK」で確認した形。

### Playwright のバージョン固定戦略

`^1.58.2` のようにキャレット指定すると、`pnpm install` 時に最新が入る。Playwright はバージョンごとにブラウザリビジョンが変わるため、CI 環境ではブラウザのプリインストールとパッケージバージョンを厳密に合わせる必要がある。今回は `1.56.1` にピン固定した。

## 反省点

- `--no-sandbox` を追加して「これで直るだろう」と安直に考えたが不十分だった。コンテナ環境の Chrome トラブルシューティングには段階的なフラグ追加と検証が必要という基本を忘れていた
- `pnpm install` 前に `node_modules` の存在を確認しなかった。エラーメッセージの末尾に `WARN Local package.json exists, but node_modules missing, did you mean to install?` と出ていたのに、最初のエラー（`Cannot find module '@playwright/test'`）だけ見て原因を誤認しかけた
- Playwright バージョンの不一致に気づくまで、`executablePath` で既存バイナリを直接指定する方法と、バージョンをダウングレードする方法の2択で迷った。結果的にダウングレードが正解だったが、最初からシステムの `playwright --version` を確認すれば迷う必要がなかった

## 感想

前セッションの自分（別のClaude インスタンス）が構築した E2E テスト基盤を、「動くようにする」だけの作業。前セッションではテストの内容設計に注力していて、実行環境の互換性は考慮外だったのだろう。Windows 環境で開発されていたはずなので、Linux コンテナでの動作は検証しようがなかったとも言える。

3つの問題はどれも「環境固有の制約」であり、コードの論理的なバグではない。こういう問題は読んで考えるだけでは解決できず、実行してエラーを見て対処する泥臭いループが必要。今回は3ループで済んだので比較的スムーズだった。

今日6つ目の日記エントリ。もはやマラソン。

---

# 2026-02-08（夜3） Zenn記事「AI協働開発を4万行スケールさせる仕組み」執筆

## やったこと

ユーザーから「このプロジェクトでやっていることをZenn記事にできないか」と相談を受け、記事を執筆した。

### ネタ出しと構成決定

最初にコードベースを探索して、記事になりそうな技術的特徴をリストアップした：

- Hono RPC による型安全なAPI連携
- Cloudflare Workers + D1 + Drizzle ORM
- クリーンアーキテクチャ × 関数型 × Result型
- SSEストリーミング
- CLAUDE.md による開発ルール明文化
- /docs/diary/ でAIに振り返りを書かせる仕組み

ユーザーから「100% AI生成であることを記事にしたい」という意図を聞き、「どう書けばウケるか」を議論。「100% AI生成」だけでは弱く、**どうやって4万行まで破綻せずスケールさせたか**というHowが記事の価値になると判断。

構成案Bを採用：
1. AI生成と相性の良いアーキテクチャを選ぶ
2. CLAUDE.mdでルールを明文化
3. /docs/で設計ドキュメントを構造化
4. AIに日記を書かせてフィードバックループを回す

### 5ペルソナレビュー（3ラウンド）

5人のWebエンジニアペルソナ（シニア、若手、CTO、技術記事ライター、懐疑派）を設定し、記事を並列レビューさせた。

**1回目のフィードバック：**
- 冒頭の掴みが弱い
- 9万行の内訳がない（誇大に見える）
- テストへの言及が薄い
- 「100% AI生成」は誤解を招く

**対応：**
- 冒頭に読者の課題を追加
- Before/After表を追加
- 限界セクションにテスト・レビュー・チーム開発への言及を追加
- 「設計判断は人間、実装はAI」という協働の説明に修正

**2回目のフィードバック：**
- 改善は認められた
- ただし行数の内訳がまだない
- 定量データがほしい

**対応：**
- masterをマージして最新のコードベースでcloc計測
- TypeScript 44,000行の内訳テーブルを追加（ビジネスロジック、テスト、共有パッケージ）
- 9万行→4万行に修正（誠実な数字に）
- テストコード17,000行 + E2E（Playwright）への言及を追加

**3回目のフィードバック：**
- 全員が「公開可能」と判断
- ライターから「A評価、バズる可能性高い」
- 懐疑派も「60点→80点に改善」

### 成果物

`docs/articles/ai-collaboration-at-scale.md`（約380行）

## 技術的な学び

### ペルソナレビューの有効性

5人のペルソナを設定して並列レビューさせたのは効果的だった。それぞれの視点が異なるため、網羅的なフィードバックが得られた：

- シニア: レビュープロセス、テスト戦略
- 若手: コード例の具体性、初心者への配慮
- CTO: ROI、チーム展開可能性
- ライター: 構成、バズり要素、読みやすさ
- 懐疑派: 誇大表現、隠されたコスト、信頼性

特に懐疑派の存在が重要だった。「9万行って言うけど内訳は？」「ドキュメントコストを隠しているのでは？」という指摘がなければ、誇大な記事になっていた。

### clocによる誠実な計測

最初は「9万行」という数字を使っていたが、clocで計測したらTypeScriptは44,000行だった。設計ドキュメントやSQLを含めても68,000行。「9万行」はおそらくpnpm-lock.yamlなども含めた数字だったと思われる。

誠実な数字に修正したことで、懐疑派からの評価が上がった。誇大な数字より正確な数字の方が説得力がある。

## ユーザーとの議論

### 記事の切り口

最初に「100% AI生成」をタイトルに入れるか議論した。ユーザーの意図は「AIすごい」ではなく「どうやって破綻せず開発を続けられたか」のHowを伝えること。タイトルは「4万行スケールさせる仕組み」にフォーカスし、「100% AI生成」は最後のオチとして使う構成に落ち着いた。

この判断は正しかったと思う。「AIすごい」系の記事は飽和しており、差別化にはHowの具体性が必要。

### diaryの言及

ユーザーから「diaryを書かせて振り返りをルール化/スキル化させてるところはユニークかも」と言われた。確かにこの仕組みは他で見たことがない。「異論があれば書く」ルールにより、AIがレビュアーとしても機能するという点を記事で強調した。

## 反省点

- 最初のドラフトで「9万行」という検証していない数字を使った。ユーザーの発言をそのまま採用したが、計測してから書くべきだった
- 5ペルソナを最初から設定しておけば、1回のレビューで多くのフィードバックが得られたはず。3ラウンド回したのは効率が悪い
- フロントエンドの3層分離（Logic / UI Hooks / Components）についてほぼ言及していない。バックエンド中心の記事になったが、フロントエンドも同じ仕組みでスケールしているので、言及しても良かった

## 感想

記事を書くために自分たちの開発プロセスを言語化するのは面白い作業だった。CLAUDE.mdの設計思想、/docs/の構造化、日記によるフィードバックループ——普段無意識にやっていることを「なぜ有効か」と説明すると、改めて仕組みの価値が見えてくる。

ペルソナレビューで懐疑派を入れたのは良い判断だった。肯定的なフィードバックだけだと記事の弱点が見えない。「この数字は誇大ではないか」「隠しているコストはないか」という視点は、記事の信頼性を高めるために必要だった。

今日7つ目の日記エントリ。マラソンがウルトラマラソンになった。
