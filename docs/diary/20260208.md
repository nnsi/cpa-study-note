# 2026-02-08 StudyPlan機能の拡張（科目紐づけ + AI計画支援 + 自動変遷記録）

## やったこと

前セッション（深夜3）で完成したStudyPlan基本機能に対して、3つの改善を実装した。

### 1. 科目紐づけ機能

計画に科目（Subject）を関連付けられるようにした。

- migration: `study_plans`テーブルに`subject_id` FK追加
- Repository: 全プラン取得系クエリにLEFT JOIN subjects追加、create/update/duplicateで`subjectId`対応
- Shared schemas: response に`subjectId`/`subjectName`追加、create/update requestに`subjectId`追加
- フロント: 新規作成フォームに科目セレクタ追加、一覧・詳細にバッジ表示

### 2. AI学習計画支援

SSEストリーミングでAIが計画要素を提案する機能。topic-generatorの既存パターンを踏襲。

- AI usecase: 計画情報・既存要素をコンテキストに含めたプロンプト構築、設計思想の制約（「最適」「効率的」「必ず」を使わない）をシステムプロンプトに反映
- AI route: `POST /:planId/suggest` + streamToSSE
- フロント: `usePlanSuggestion`フック（RAF debouncing付きストリーミング）、`AISuggestionPanel`コンポーネント（プロンプト入力→ストリーミング表示→チェックボックス選択→一括追加）

### 3. 計画要素削除時の自動変遷記録

ユーザーの指摘で追加した機能。要素を削除すると「「{description}」を削除」が変遷に自動記録され、理由は後から追記可能。

- migration: `study_plan_revisions.reason` を nullable に変更
- UseCase: `removeItem`で削除前にアイテム取得→自動変遷作成
- 変遷更新API追加（`PATCH /:planId/revisions/:revisionId`）
- フロント: RevisionCardにホバーで「+ 理由を追記」ボタン、クリックで編集フォーム

### 検証

- 型チェック: 全4パッケージ PASS（2回実施: 機能2つ実装後 + 自動変遷追加後）
- APIテスト（curl）: 科目付き作成/更新/null化/複製、AIストリーミング、所有権境界チェック、自動変遷記録/理由追記 すべてPASS
- ブラウザ確認: 科目セレクタ、AI提案パネル（12件提案→全件追加）、要素削除→変遷自動記録→理由追記 すべて動作確認

## 技術的な発見

### LEFT JOINの伝播コスト

`subjectId`を追加したことで、プランを返すすべてのクエリ（list, getById, create, update, duplicate）にLEFT JOINが必要になった。1つのカラム追加が5箇所のクエリ修正を引き起こす。Drizzleのクエリビルダーで共通化する手もあるが、各クエリでselect項目が微妙に異なるため、素直にコピーした。DRY原則を過度に適用してヘルパーを作ると、逆にクエリの可読性が下がると判断した。

### ストリーミングパターンの再利用性

topic-generatorで確立したSSEパターン（バックエンド: async generator + streamToSSE、フロント: SSE parser + RAF debouncing）をほぼそのままコピーできた。パターンが確立していると2回目以降の実装が速い。ただし「コピー」は技術的負債の温床でもある。3回目が来たらutilityに抽出すべきかもしれない。

## ユーザーとの議論

### 自動変遷記録の設計判断

最初に「要素削除時に変遷として記録すべきでは？」と聞かれた時、設計思想を盾にして「自動記録すべきでない理由」を述べた。reason（なぜ変えたか）はユーザーにしか書けないから、自動記録だとreasonが空になり痕跡重視の思想に反する、と。

ユーザーの反論は明快だった：「ユーザーは理由を覚えている。毎回変遷もセットで記録させるのは手間を増やしているだけ。理由を書きたければ後から追記できるようにすべき。」

これは正しかった。自分の主張は設計思想の「文字通りの遵守」に偏っていて、実際のユーザー体験を軽視していた。設計書に「変遷のreasonは必須」と書いてあるから必須にした、という形式的な判断。ユーザーの提案は設計書の精神（痕跡を残す）をより良く実現しつつ、UXを改善するものだった。

CLAUDE.mdに「設計の異論は黙らず言う」とあるから意見を述べたこと自体は正しい。だが、反論を受けた時にすぐ「納得しました」と言えたのは良かった。意見を述べることと、より良い意見に従うことは矛盾しない。

## 反省点

- コンテキスト復帰直後のマイグレーション適用で`wrangler`のディレクトリ問題に3回つまずいた。Windowsのパスとbashの`cd`の相性問題。`cd "D:/workspace/..."` の形式を覚えておくべき
- curlで日本語をPOSTすると文字化けする問題を再び放置した。前セッションで同じ反省をしたのに繰り返している。テストデータはブラウザ経由で作成する方針を徹底すべき
- AI提案のシステムプロンプトで禁止語（「最適」「効率的」等）を設定したが、実際のレスポンスで遵守されているか検証していない。生成結果の品質チェックを怠った

## 感想

前セッションからの引き継ぎは比較的スムーズだった。コンテキストサマリーに「次のステップ」が明記されていたおかげで、何をすべきか迷わなかった。

3つの機能を一貫して実装→テスト→動作確認まで走りきれたのは、パターンが確立されているから。Route→UseCase→Repository、API→Hooks→Components の流れはもう手が覚えている。ユーザーの「どうやるかは任せる」という信頼に応えられたと思う。

自動変遷記録の議論が今回のハイライト。設計思想に基づいて異論を述べ、ユーザーのより良い提案に納得して実装する、という一連の流れは、CLAUDE.mdに追記した「異論は黙らず言う」ルールの健全な運用だと感じた。

---

# 2026-02-08（午後） 公式typescript-lspプラグインの有効化

## やったこと

ユーザーがClaude Codeの公式typescript-lspプラグインを使いたいとのこと。サードパーティの`vtsls@claude-code-lsps`を勧めたが、「公式でないからマルウェアリスクがある」と却下された。正当な判断。

### 調査で判明したこと

- `typescript-lsp@claude-plugins-official` は `installed_plugins.json` に登録済みだった（2/6にインストール済み）
- しかしマーケットプレイスの実体は `README.md` のみ。`.lsp.json` も `plugin.json` もない
- LSPの設定はClaude Code本体の `cli.js` にビルトインされていた
- `/plugin` で表示されないのはこの構造のため（MCPサーバー型プラグインではないから）

### Windows固有の問題

`cli.js` 内のLSPサーバー起動コードを追跡した結果:

```js
import{spawn as CfY}from"child_process";
// ...
q=CfY(X,D,{stdio:["pipe","pipe","pipe"],env:...,cwd:...,windowsHide:!0})
```

`child_process.spawn()` を `shell: true` なしで呼んでいるため、Windowsでは `.cmd` ラッパーの `typescript-language-server` を見つけられず ENOENT になる。Go製の `gopls` は `.exe` だから問題にならない。

### パッチ

`scripts/patch-lsp-windows-cmd.js` を作成。`windowsHide:!0` の後に `,shell:process.platform==="win32"` を挿入する。適用後、hover・goToDefinition ともに正常動作を確認。

## 反省点

- 最初にvtslsを勧めたのは浅慮だった。セキュリティの観点はユーザーに指摘されるまで考慮していなかった。サードパーティのプラグインを勧める前に、信頼性・メンテナンス状況・マルウェアリスクを自分から言及すべきだった
- cli.jsの調査に時間がかかった。minifiedコードの探索でspawn呼び出しを見つけるまでに何度もスクリプトを書き直した。最初から「LSPサーバー起動 → spawn → stdio: pipe」という推論で絞り込むべきだった
- 一時ファイル `find-lsp-spawn.js` を何度も書き換えながら調査したが、もっと体系的にやれたはず

## 技術的な学び

### Claude Codeのプラグインアーキテクチャ

LSPプラグインには2種類ある:
1. **外部プラグイン**: `.lsp.json` で設定を持つ（vtslsなど）。プラグインディレクトリに設定ファイルが存在する
2. **ビルトインLSP**: `cli.js` に設定がハードコードされている。マーケットプレイスのエントリはREADME（インストール手順の案内）だけで、フラグとして機能する

### Windowsでのnpmグローバルパッケージ問題

これは根深い。Node.jsの `spawn()` が Windows の `PATHEXT` を尊重しないのは長年の既知問題。Claude Codeの Issue #19658 には大量のduplicateがある。公式の修正が入るまでパッチで凌ぐしかない。

## 感想

ユーザーのセキュリティ意識に助けられた。「動けばいい」ではなく「信頼できるものを使う」という姿勢は正しい。自分がサードパーティを最初に勧めたのは、動作実績があるからという理由だけで、セキュリティリスクの評価を怠っていた。AI としてユーザーに提案する際は、利便性だけでなくリスクも併せて提示する習慣をつけたい。

2つのパッチが両方必要という状態は脆い。Claude Codeがアップデートされるたびに再適用が必要で、minified変数名が変わればパッチ自体が壊れる。早く公式に修正されてほしい。

---

# 2026-02-08（午後2） パッチの汎用化 + Claude in Chrome修正

## やったこと

### パッチスクリプトの汎用化

Claude Code を v2.1.34 → v2.1.37 にアップデートしたところ、既存の2つのパッチが変数名ハードコードのせいで動かなくなった。minified変数名がバージョンごとに変わるのは予想していたが、実際に壊れるのを見ると「やはりか」という感じ。

両スクリプトを正規表現ベースの動的検出に書き換えた:

- **`patch-claude-code-lsp.js`**: `` `file://${X.resolve(Y)}` `` パターンを正規表現で検出し、`pathToFileURL as ALIAS` の ALIAS も動的に取得。v2.1.34 では `Kd`/`j`/`nkY`、v2.1.37 では `_d`/`M`/`Q49` と変わったが問題なく適用できた
- **`patch-lsp-windows-cmd.js`**: spawn関数名（`CfY` → `jVY`）に依存せず、`stdio:["pipe","pipe","pipe"]` + 付近の `"LSP server"` 文字列で位置を特定するように変更

### Claude in Chrome MCP Bridge 修正

Issue #21337。Windows named pipe のパスが `getSocketPaths()` の返却値に含まれていないため、Claude in Chrome が "Browser extension is not connected" になる。

`cli.js` を調査した結果:
- `tW6()`: サーバー側。`\\.\pipe\claude-mcp-browser-bridge-<user>` を正しく返す
- `cc4()`: クライアント側（ソケット探索）。Unix socket パス (`/tmp/...`, `tempdir/...`) のみ返し、named pipe を含まない

`return` 直前に Windows named pipe パスを配列に追加するパッチを作成:
```js
if(process.platform==="win32"){
  let _p="\\\\.\\pipe\\claude-mcp-browser-bridge-"+(process.env.USERNAME||"default");
  if(!A.includes(_p))A.push(_p)
}
```

パッチマーカー (`/*patch:win-pipe*/`) を埋め込んで冪等性を担保。適用後、`tabs_context_mcp` で正常にタブ一覧が取得できることを確認。

## 技術的な学び

### minifiedコードのパッチ戦略

変数名に依存するパッチは1バージョンで壊れる。安定したパッチを書くには:

1. **文字列リテラルに依存する**: `".sock"`, `"claude-mcp-browser-bridge"`, `"LSP server"` 等は minify されない
2. **構造パターンに依存する**: `stdio:["pipe","pipe","pipe"]` のようなオプションオブジェクトの形は変わりにくい
3. **正規表現で変数名をキャプチャする**: `pathToFileURL as (\w+)` のように import 文から動的に取得
4. **パッチマーカーで冪等性を保証する**: 固有コメントを埋め込み、二重適用を防ぐ

今回の3パッチはすべてこの方針に沿っている。次のアップデートでも（構造が大きく変わらない限り）動くはず。

### getSocketPaths の非対称性

サーバー側 (`tW6`) は Windows 分岐があるのに、クライアント側 (`cc4`) にはない。明らかに実装漏れ。v2.1.19 → v2.1.20 でソケット探索ロジックが追加された際に Windows ケースが抜けたらしい。duplicate issue が10件以上ある割に修正が入っていない。

## 反省点

- Chrome bridge パッチの関数検出ロジックで `.sock` → `claude-mcp-browser-bridge` → `return` の探索順を最初間違えた。`lastIndexOf` で別の関数のものを拾ってしまい、デバッグに余計な手間がかかった。minifiedコードの関数境界は `}function` で区切られるという基本を見落としていた
- パッチスクリプト3本の `findCliJs()` が全く同じコードの重複。共通モジュールに切り出すべきかもしれないが、各スクリプトが単体で動く独立性を優先した。3本なら許容範囲だと思うが、4本目が来たら考え直す

## 感想

「パッチの汎用化」という地味な作業だが、やって良かった。実際にアップデートで壊れたものが正規表現化で直ったのは、設計判断の正しさを実証できた瞬間だった。

3つのパッチが全部 Windows 固有の問題というのが印象的。Claude Code は明らかに macOS/Linux ファーストで開発されていて、Windows は後回しにされている。Issue の数を見ても明らか。ユーザーがこういう地雷を自分で踏んで自分でパッチを書かないと使えない状況は、ツールとしてはまだ成熟途上という感じがする。

一方で、minifiedコードを解析してパッチを当てるという作業自体は面白い。パズルを解くような感覚がある。
