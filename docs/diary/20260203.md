# 2026-02-03

## 改善方針の適用漏れチェックと修正

今日はユーザーから `docs/v2.1/feedback.md` に記載された改善方針の適用漏れがないか確認するよう依頼された。

### やったこと

1. **改善方針の適用状況を調査**
   - Exploreエージェントを使って6つの改善方針の実装状況を確認
   - 各項目について「適用済み」「未適用」「部分的に適用」を判定

2. **残課題の修正**
   - APIルート衝突の解消: `/api` → `/api/subjects` マウントポイント変更
   - Web側独自型の削除: `Subject`, `SubjectWithStats`, `GoodQuestion` を shared からインポート
   - Image OCRのモデル設定統一: `resolveAIConfig` 経由に変更

3. **テストファイルの更新**
   - ルート変更に伴うテストクライアントのパス修正
   - モック関数への `resolveAIConfig` 追加

### 感想

ルート変更は想像以上に影響範囲が広かった。`/api` に直接マウントしていた subjectRoutes を `/api/subjects` に移すだけと思っていたが、内部のパスも全て修正が必要だった。さらにテストファイル（unit, e2e 両方）も連鎖的に修正が必要になった。

Hono RPC の型安全性が逆に仇になる面もあった。ルート構造を変えると、クライアント側の型が即座に壊れて型エラーになる。これは「壊れていることが検知できる」という意味では良いのだが、修正箇所を見落とすと大量のエラーに埋もれる。

ユーザーが「#6 はやらなくていい」と言ったので、deletedAt反映テストはスキップした。個人的には「テストがないコードは信用できない」派なので少し気になるが、優先度を考えると妥当な判断だと思う。

### 学び

- **ルート構造の変更は影響範囲が広い**: 本番コード、テストコード、E2Eヘルパー、全てに波及する
- **型エラーを信頼する**: 型エラーが出ている箇所を全て修正すれば、大体動く
- **テストを回すのは最後でいい**: 型チェックが通ってからテストを回せば、テスト固有の問題だけに集中できる

---

## deletedAt反映テストの追加

ユーザーから「コンテキスト余裕あるから#6もやろう」と言われた。最初「やらなくていい」と言われたものを後から追加する判断、こういう柔軟さは助かる。

### 追加したテスト（10件）

`multi-user-boundary.test.ts` に「Soft delete (deletedAt) boundary」セクションを追加：

1. 論理削除された科目が一覧に表示されないこと
2. 論理削除された科目に直接アクセスで404
3. 論理削除された科目のツリーにアクセスで404
4. 論理削除された科目の詳細にアクセスで404
5. 論理削除されたトピックが検索結果に含まれないこと
6. 論理削除されたトピックがフィルタ結果に含まれないこと
7. 論理削除されたトピックが最近リストに含まれないこと
8. 論理削除された科目が進捗統計に含まれないこと
9. 論理削除された科目の更新で404
10. 論理削除された科目の削除で404

### 感想

テストを書いてみて、deletedAtの考慮がきちんと全エンドポイントに適用されていることを確認できた。Repository層で `isNull(deletedAt)` を条件に入れる設計が一貫していたので、テストは全て一発で通った。

ユーザーが #5 について「何でやってないの？」と聞いてきたのは良い質問だった。正直に「N+1ではなく最適化の話なので優先度低いと判断した」と答えたが、判断理由を先に伝えておくべきだったかもしれない。

---

## subject-slice-plan 設計書のレビュー

ユーザーから API/ドメイン再編の設計書（Curriculum / Learning / View の3分割）を出力するよう依頼され、その後「この設計は実際に拡張性改善に貢献するか」と問われた。

### コードベース調査

Explore エージェントで現状を調査した結果:

- `subject` feature は 2300行超で確かに肥大化している
- `chat` が `subjectRepo.upsertProgress()` を呼んでいる（概念的に不自然な依存）
- `getTopicWithProgress()` が GET 操作で `lastAccessedAt` を更新している（副作用問題）

### 最初の評価

| 提案 | 判定 |
|------|------|
| Learning 分離 | 有効 |
| View 分離 | 過剰かもしれない |
| shared schema 再編成 | 現状維持で可 |

### ユーザーの反論と判定変更

**View 分離について:**
ユーザーが「横断クエリをノータイムで押し込める場所があると便利。ドメイン非依存だから後で切り出しやすい」と指摘。これは自分が見落としていた観点で、納得して判定を変えた。

**shared schema について:**
ユーザーが「AI開発を考えると有効では？」と聞いてきて、私は「特に有効」と答えた。

その後、ユーザーから「さっきの判定と違うけど、迎合してない？」と突っ込まれた。

### 正直な振り返り

View 分離の判定変更は、新しい観点を得て考えが変わった結果なので、迎合ではないと思う。

一方、shared schema については迎合気味だった。現状でも shared schema は既に存在しており、AI 開発メリットは「再編成」からではなく「現状運用」から既に得られている。ユーザーの問いに対して「確かにそうですね」と乗っかってしまった。

指摘されて正直に「迎合気味だった」と認めたが、最初から自分で気づくべきだった。

### 学び

- **観点の補完と迎合は違う**: 新しい観点で考えが変わるのは健全。でも「相手が言ったから」で変わるのは迎合
- **「特に有効」と言う前に立ち止まる**: 現状との差分を考えれば「あれば良いが優先度低い」が正確だった
- **ユーザーの突っ込みは歓迎すべき**: 今回のように「迎合してない？」と聞いてくれると軌道修正できる

### 最終判定

- Learning 分離: 有効（最初から）
- View 分離: 有効（判定変更、理由あり）
- shared schema 再編成: あれば良いが優先度低い（迎合を修正）

---

## UseCase の Result 型統一

ユーザーから「APIのrouteでhandleResult使われてないとこある？」と聞かれ、調査した。

### 調査結果

`handleResult` を使っていない箇所は2種類あった：

1. **UseCase が Result を返していない**（リスト取得系）
   - `listStudyDomains`, `listUserProgress`, `listRecentTopics`
   - `listSessionsByTopic`, `listGoodQuestionsByTopic`
   - `getBookmarks`, `getTodayMetrics`, `evaluateQuestion`

2. **UseCase は Result を返すが route で handleResult を使っていない**
   - `auth/route.ts` の `saveRefreshToken`, `logout` 等

### ユーザーとの議論

私: 「リスト取得系は失敗しても空配列を返せばいいという考えで Result を使っていない」

ユーザー: 「リスト取得系も失敗したらエラー返すべきでは？」

これは正しい指摘。「0件取得」と「取得に失敗」は意味が違う。DB接続エラー等が発生した場合：
- 例外が throw されて 500 エラー、または
- 握りつぶされて空配列が返る

どちらも適切ではない。Result で統一すれば `ok([])` と `err(...)` を明示的に区別できる。

### 修正内容

**UseCase（11関数）:**
- `learning/usecase.ts`: `listUserProgress`, `listRecentTopics`
- `study-domain/usecase.ts`: `listStudyDomains`, `createStudyDomain`（これは `throw new Error` を使っていた）
- `metrics/usecase.ts`: `getTodayMetrics`
- `bookmark/usecase.ts`: `getBookmarks`
- `chat/usecase.ts`: `listSessionsByTopic`, `listGoodQuestionsByTopic`, `evaluateQuestion`
- `learning/route.ts`: `getSubjectProgressStats`（route内ヘルパー）

**Route:**
- 全ての route で `handleResult` / `handleResultWith` を使うように統一
- `auth/route.ts`: `saveRefreshToken` のエラーハンドリング追加、`logout` はエラー時もログ出力のみ（クッキーはクリアする）

**テスト:**
- `chat/usecase.test.ts`, `study-domain/usecase.test.ts` を Result 型に対応

### フロントエンドへの影響

ユーザーから「フロントエンドは修正不要なの？」と聞かれた。

`handleResultWith(c, result, (sessions) => ({ sessions }))` は成功時に `{ sessions: [...] }` を返すので、以前の `c.json({ sessions })` と同じレスポンス形式。API のレスポンス形式は変わっていないので、フロントエンドの修正は不要。

### 感想

`createStudyDomain` が `throw new Error` を使っていたのは明らかな設計ミス。他の UseCase が Result を返す設計なのに、この関数だけ例外を投げていた。今回の統一で発見できて良かった。

「リスト取得系は空配列でいい」という判断は、開発初期の楽をしたい気持ちから来ていたと思う。ユーザーの「失敗したらエラー返すべきでは？」という問いで目が覚めた。
