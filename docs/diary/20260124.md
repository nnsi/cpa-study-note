# 2026-01-24

## 今日やったこと

### Terraform構成の実績ベースへの修正

昨日作成したTerraform構成を、ユーザーの別プロジェクト（ai-assistant-scheduler）の実績ある構成に合わせて修正した。

主な変更点:
- ディレクトリ名: `terraform/` → `infra/`
- Cloudflare provider: `~> 4.0` → `~> 5.1`
- Terraform version: `1.7.0` → `1.10`
- 環境分離: workspace → stg/prod両方を同一tfファイルで定義
- Workers Script: Terraform管理から削除（wranglerに任せる）
- D1に `lifecycle { ignore_changes = all }` を追加

最初に作った構成はworkspaceで環境分離する設計だったが、実績構成はstg/prodリソースを両方定義するシンプルな方式だった。実績があるなら素直にそれに従うのが正解。

### CI/Deploy ワークフローの作成

ai-assistant-schedulerを参考に、以下を作成:

- `ci.yml`: PR時の変更検出 + テスト + 型チェック
- `deploy.yml`: master push → staging、手動 → 選択可

参考にしたポイント:
- `dorny/paths-filter` で変更検出（無駄なジョブをスキップ）
- `printenv` でシークレットをwranglerに渡す（プロセスリスト露出回避）
- GitHub Environment Variables で環境別設定を管理
- Apply後のoutput表示

### wrangler.toml の環境設定追加

api/web両方のwrangler.tomlにstaging/production環境設定を追加。webはWorkers Static Assetsで静的サイト配信する構成。

### セットアップガイドの作成

ユーザーが手動でやる必要がある作業をチェックリスト形式でまとめた（`docs/setup-guide.md`）。最初は説明文形式で書いたが、ユーザーから「チェックリスト形式で」とリクエストがあり書き直した。

## 反省

最初のTerraform構成で独自設計をしてしまった。ユーザーに「別プロジェクトで動いてる構成がある」と言われて初めて確認した。最初から「既存で動いてる構成はありますか？」と聞くべきだった。

セットアップガイドも最初は説明文ベースで書いた。ドキュメントの目的（手順を追って実行する）を考えれば、チェックリスト形式の方が適切だった。「誰がどう使うか」を先に考えるべき。

## 学び

- 実績ある構成があるなら、まずそれを確認して合わせる
- ドキュメントは「誰がどう使うか」で形式を決める
  - 手順書 → チェックリスト
  - 解説 → 説明文
- CI/CDの設計は、実際に動いてるプロジェクトを参考にするのが効率的

## 雑感

今日はほぼインフラ・CI/CD周りの作業だった。アプリケーションコードを書くより、こういう基盤整備の方が地味だけど重要。ユーザーが「まだ環境用意するつもりない」と言っていたので、masterへのpush時のデプロイは無効化しておいた。準備が整ったらコメントを外すだけで有効化できる。

---

## セキュリティレビューと改善（夜）

### やったこと

ユーザーから「セキュリティレビューしてほしい」と依頼があり、ExploreエージェントとCodex CLIの2つで並行レビューを実施した。

**発見したCritical問題:**
1. CORS全開放（`cors()` デフォルト設定）
2. 開発モード認証バイパスが本番で有効になる可能性
3. JWTトークンをlocalStorageに保存（XSSで盗まれる）
4. JWT SECRET強度検証なし

**実施した修正:**

1. **環境変数の整理**: `AUTH_MODE` → `ENVIRONMENT`（local/staging/production）
   - 「認証モード」ではなく「動作環境」として分離
   - localのみ認証バイパス許可、stg/prodでは不可能に

2. **CORS設定**: 環境に応じて動的設定
   - local: 全許可
   - stg/prod: `WEB_BASE_URL`のみ許可

3. **JWT周りの大改修**:
   - アクセストークン: 15分、インメモリ保持
   - リフレッシュトークン: 30日、HttpOnly Cookie、DBにハッシュ保存
   - refresh_tokensテーブル新規作成
   - フロントエンド: リロード時・401時に/refresh呼び出し

### 反省

Codexが発見した「メッセージ評価の認可漏れ」は、Exploreエージェントでは検出できなかった。2つのツールで並行レビューしたのは正解だった。片方だけだと見落としがあった。

JWT周りの改修は結構大規模になった。最初からアクセストークン/リフレッシュトークン分離で設計しておけば良かったが、後から直すことになった。セキュリティは後付けより最初から考えるべき、という典型例。

### 学び

- セキュリティレビューは複数の視点で行う価値がある
- 環境変数は「何のための設定か」を明確にする命名が重要
  - `AUTH_MODE=dev` より `ENVIRONMENT=local` の方が意図が明確
- トークン設計はSPA開発の初期段階で決めるべき
  - アクセストークン: 短命、メモリ
  - リフレッシュトークン: 長命、HttpOnly Cookie
  - この構成は後から変更するとフロントエンド全体に影響する

### 雑感

ユーザーとの対話で「AUTH_MODEじゃなくて純粋に動作環境としてstg/prodが分かる方が良いね」という提案があった。これは良い指摘だった。自分は「認証モード」と「動作環境」を混同した設計をしていた。

リフレッシュトークンのDB保存について「usersテーブルとは別にテーブル切り出して」という要件も明確で助かった。最初は同じテーブルに入れようかと思ったが、分離した方がセッション管理（複数デバイス対応、強制ログアウト等）が柔軟にできる。

---

## セキュリティレビュー残項目の対応（夜2）

### やったこと

先ほどのセキュリティレビューで作成した `docs/security-review.md` のHigh/Medium/Low項目を対応。

**対応した項目:**

| 重大度 | 項目 | 対応内容 |
|--------|------|----------|
| High | 認可漏れ（メッセージ評価） | `getMessageForEvaluation`にuserId追加、セッション経由で所有権チェック |
| High | 入力サイズ制限なし | Zodスキーマにmax制限追加（content: 10000, userMemo: 50000, 配列: 50件など） |
| High | MIME Typeバリデーション | `z.enum(["image/jpeg", "image/png", "image/gif", "image/webp"])` |
| High | ファイル名サニタイゼーション | `sanitizeFilename`関数追加、パストラバーサル防止 |
| Medium | エラー情報漏洩 | Google OAuthのエラーメッセージを抽象化（内部ログは保持） |
| Medium | R2キーからユーザーID除去 | `images/${userId}/${imageId}/${filename}` → `images/${imageId}/${safeFilename}` |
| Low | 依存パッケージ監査 | `pnpm audit`スクリプト追加 |
| Low | AIエラー処理 | ストリーミング中のエラーをtry-catchでキャッチしてユーザーに通知 |

**スキップした項目:**
- レート制限（ユーザー判断でスキップ、KV設定が必要でヘビー）
- セッションテーブル（大規模変更）
- OCR暗号化（大規模変更）
- Google OAuth ID Token検証（大規模変更）

### 反省

プランモード使用時、最初はシステムが指定するパス（`C:\Users\...\.claude\plans\`）にプランファイルを作ってしまった。ユーザーから「planファイルは必ずdocs/以下に」と指摘されて `docs/plan/security-fix-plan.md` に書き直した。プロジェクトのドキュメント規約を確認すべきだった。

### 学び

- 入力バリデーションは「何を許可するか」を明示的に定義する
  - 文字列長: max制限
  - ファイル形式: enumでホワイトリスト
  - 配列: 要素数と各要素の長さ両方を制限
- ファイル名サニタイズは多層防御で
  - Zodスキーマで一次フィルタ
  - usecase層でサニタイズ関数を通す
- R2キーにユーザーIDを含めない
  - DBで関連付けを管理すれば十分
  - キーからユーザーを推測させない

### 雑感

セキュリティ修正は地味だが重要な作業だった。認可漏れ（IDOR）は「他ユーザーのリソースに直接アクセスできる」という典型的な脆弱性で、見落としがちだが影響は大きい。今回はセキュリティレビューで発見できて良かった。

レート制限をスキップしたのはユーザーの判断だが、個人的には早めに対応した方が良いと思う。AI API呼び出しのあるエンドポイントは、悪意のある連続リクエストでコストが跳ね上がるリスクがある。ただ、KV設定が必要になるのは確かに面倒なので、優先度の判断としては理解できる。
