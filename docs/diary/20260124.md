# 2026-01-24

## 今日やったこと

### Terraform構成の実績ベースへの修正

昨日作成したTerraform構成を、ユーザーの別プロジェクト（ai-assistant-scheduler）の実績ある構成に合わせて修正した。

主な変更点:
- ディレクトリ名: `terraform/` → `infra/`
- Cloudflare provider: `~> 4.0` → `~> 5.1`
- Terraform version: `1.7.0` → `1.10`
- 環境分離: workspace → stg/prod両方を同一tfファイルで定義
- Workers Script: Terraform管理から削除（wranglerに任せる）
- D1に `lifecycle { ignore_changes = all }` を追加

最初に作った構成はworkspaceで環境分離する設計だったが、実績構成はstg/prodリソースを両方定義するシンプルな方式だった。実績があるなら素直にそれに従うのが正解。

### CI/Deploy ワークフローの作成

ai-assistant-schedulerを参考に、以下を作成:

- `ci.yml`: PR時の変更検出 + テスト + 型チェック
- `deploy.yml`: master push → staging、手動 → 選択可

参考にしたポイント:
- `dorny/paths-filter` で変更検出（無駄なジョブをスキップ）
- `printenv` でシークレットをwranglerに渡す（プロセスリスト露出回避）
- GitHub Environment Variables で環境別設定を管理
- Apply後のoutput表示

### wrangler.toml の環境設定追加

api/web両方のwrangler.tomlにstaging/production環境設定を追加。webはWorkers Static Assetsで静的サイト配信する構成。

### セットアップガイドの作成

ユーザーが手動でやる必要がある作業をチェックリスト形式でまとめた（`docs/setup-guide.md`）。最初は説明文形式で書いたが、ユーザーから「チェックリスト形式で」とリクエストがあり書き直した。

## 反省

最初のTerraform構成で独自設計をしてしまった。ユーザーに「別プロジェクトで動いてる構成がある」と言われて初めて確認した。最初から「既存で動いてる構成はありますか？」と聞くべきだった。

セットアップガイドも最初は説明文ベースで書いた。ドキュメントの目的（手順を追って実行する）を考えれば、チェックリスト形式の方が適切だった。「誰がどう使うか」を先に考えるべき。

## 学び

- 実績ある構成があるなら、まずそれを確認して合わせる
- ドキュメントは「誰がどう使うか」で形式を決める
  - 手順書 → チェックリスト
  - 解説 → 説明文
- CI/CDの設計は、実際に動いてるプロジェクトを参考にするのが効率的

## 雑感

今日はほぼインフラ・CI/CD周りの作業だった。アプリケーションコードを書くより、こういう基盤整備の方が地味だけど重要。ユーザーが「まだ環境用意するつもりない」と言っていたので、masterへのpush時のデプロイは無効化しておいた。準備が整ったらコメントを外すだけで有効化できる。

---

## セキュリティレビューと改善（夜）

### やったこと

ユーザーから「セキュリティレビューしてほしい」と依頼があり、ExploreエージェントとCodex CLIの2つで並行レビューを実施した。

**発見したCritical問題:**
1. CORS全開放（`cors()` デフォルト設定）
2. 開発モード認証バイパスが本番で有効になる可能性
3. JWTトークンをlocalStorageに保存（XSSで盗まれる）
4. JWT SECRET強度検証なし

**実施した修正:**

1. **環境変数の整理**: `AUTH_MODE` → `ENVIRONMENT`（local/staging/production）
   - 「認証モード」ではなく「動作環境」として分離
   - localのみ認証バイパス許可、stg/prodでは不可能に

2. **CORS設定**: 環境に応じて動的設定
   - local: 全許可
   - stg/prod: `WEB_BASE_URL`のみ許可

3. **JWT周りの大改修**:
   - アクセストークン: 15分、インメモリ保持
   - リフレッシュトークン: 30日、HttpOnly Cookie、DBにハッシュ保存
   - refresh_tokensテーブル新規作成
   - フロントエンド: リロード時・401時に/refresh呼び出し

### 反省

Codexが発見した「メッセージ評価の認可漏れ」は、Exploreエージェントでは検出できなかった。2つのツールで並行レビューしたのは正解だった。片方だけだと見落としがあった。

JWT周りの改修は結構大規模になった。最初からアクセストークン/リフレッシュトークン分離で設計しておけば良かったが、後から直すことになった。セキュリティは後付けより最初から考えるべき、という典型例。

### 学び

- セキュリティレビューは複数の視点で行う価値がある
- 環境変数は「何のための設定か」を明確にする命名が重要
  - `AUTH_MODE=dev` より `ENVIRONMENT=local` の方が意図が明確
- トークン設計はSPA開発の初期段階で決めるべき
  - アクセストークン: 短命、メモリ
  - リフレッシュトークン: 長命、HttpOnly Cookie
  - この構成は後から変更するとフロントエンド全体に影響する

### 雑感

ユーザーとの対話で「AUTH_MODEじゃなくて純粋に動作環境としてstg/prodが分かる方が良いね」という提案があった。これは良い指摘だった。自分は「認証モード」と「動作環境」を混同した設計をしていた。

リフレッシュトークンのDB保存について「usersテーブルとは別にテーブル切り出して」という要件も明確で助かった。最初は同じテーブルに入れようかと思ったが、分離した方がセッション管理（複数デバイス対応、強制ログアウト等）が柔軟にできる。
