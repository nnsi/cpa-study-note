# 2026-02-11 テストコード一斉強化（768 → 1,446テスト）

## やったこと

ユーザーから「全体的にテストコードを強化したい。チームを組んで」と依頼を受け、Agent Team（3並列）でテストを一斉追加した。

### 事前調査

まずExploreエージェントでプロジェクト全体のテストカバレッジを調査した。

| パッケージ | テスト数 | カバレッジ |
|-----------|---------|-----------|
| packages/shared | 0 | 0% |
| apps/api | 42（unit 36 + E2E 6） | ~47% |
| apps/web | 8 | ~6% |

shared パッケージのテストが皆無、webのカバレッジが壊滅的という状態。既存テストのパターン（mock repository injection、renderHook + vi.mock、setupTestContext等）を4ファイル読んで把握した上で、6つのタスクに分解した。

### Agent Team構成

- **shared-api-libs-tester**: packages/sharedのZodスキーマテスト + apps/api/shared/libsのテスト（Task #1, #2）
- **api-feature-tester**: study-plan featureのテスト + 未テストAPIの補強（Task #3, #4）
- **web-feature-tester**: webの未テストfeature hooks/logicのテスト（Task #5）
- **自分（リーダー）**: 型エラー修正、エージェント間調整、最終検証（Task #6）

### 結果

| パッケージ | Before | After |
|-----------|--------|-------|
| packages/shared | 0 | 236 |
| apps/api | 42 | 1,004 |
| apps/web | 8 | 206 |
| **合計** | **768** | **1,446** |

+678テスト、+88%。全テスト PASS。

## 技術的な発見

### Zodスキーマとテストモックの乖離問題

今回最大の問題は、web-feature-testerが作成したテストのモックデータが、ほぼ全て `packages/shared/src/schemas/` のZod型と合っていなかったこと。6ファイルで型エラーが発生し、すべて自分が手動で修正した。

具体例:
- `bookmark/hooks.test.ts`: `userId`/`targetName`/`subjectName` → 正しくは `name`/`path`/`domainId`/`subjectId`/`categoryId`
- `study-plan/hooks.test.ts`: `name`/`description`/`targetExamDate`/`archived` → 正しくは `title`/`intent`/`scope`/`archivedAt`
- `home/hooks.test.ts`: 存在しない `goodQuestionCount` フィールド、`id`/`name` → `topicId`/`topicName`
- `subject/hooks/useSubjects.test.ts`: `userId`/`description`/`emoji`/`color`/`categoryCount` が欠落
- `subject/hooks/useTreeState.test.ts`: 存在しない `understood`/`sessionCount`/`lastAccessedAt`
- `study-domain/hooks/useStudyDomains.test.ts`: `emoji`/`color` が欠落

パターンは明確で、エージェントが「フィールド名を推測して書いている」。shared schemasを読まずに、hooksの使われ方やコンポーネントの呼び出しからモックデータを逆推測した結果、実際のZod型と乖離した。

### Agent Teamへの指示設計の教訓

3エージェントのうち、shared-api-libs-testerとapi-feature-testerはほぼ問題なく動いた。web-feature-testerだけが型エラーを量産した理由は、指示の中で「`packages/shared/src/schemas/` のZodスキーマを必ず参照してモックデータを作れ」と明示しなかったから。

APIテスト側はDB直接操作でモックを作るため型の問題が出にくい。一方、web hooksテストは `vi.mock("./api")` でAPIレスポンスをモックするため、レスポンス型の正確さが直接テストの成否に影響する。この非対称性を計画段階で認識して指示に反映すべきだった。

CLAUDE.mdの「インターフェース（型定義、設計ルール）を厳密に指定して委譲」というルールが、まさにこのケースで守れていなかった。

### exercise/route.test.tsの`.in`問題

api-feature-testerが書いた `exercise/route.test.ts` で、SQLiteColumn に `.in()` メソッドを呼んでいるコードがあった。Drizzle ORMの `inArray()` 関数を使うべきところ。エージェントにメッセージを送って修正させた。これはDrizzle固有のAPIの問題で、指示で防ぐのは難しい。

## 反省点

- **web-feature-testerへの指示が甘かった**。6ファイルの型エラーを手動修正するのに相当な時間を費やした。タスク定義に「`packages/shared/src/schemas/` の該当スキーマファイルを最初に読み、モックデータのフィールド名・型を厳密に一致させること」と一文入れるだけで防げた問題
- **修正の手順が非効率だった**。型エラーを1ファイルずつ修正していったが、最初にまとめてsharedスキーマと各テストファイルを比較して、差分をリストアップしてから一括修正すべきだった。結果的に6ファイルの修正でスキーマファイルを何度も読み直した
- **エージェントの作業品質を検証するタイミングが遅かった**。3エージェントが全タスク完了を報告した後に型チェックを実行して問題を発見した。途中で1エージェント分だけ先に型チェックを走らせていれば、他のエージェントにも早く警告できた
- **テスト数の増加幅を自慢したい気持ちがゼロではないが、数が増えたことと品質が高いことは別の話**。エージェントが書いたテストは「正常系のハッピーパス」が中心で、エッジケースやエラーハンドリングのテストは手薄。768→1,446は見栄えがいいが、カバレッジの深さはまだ足りない

## ユーザーとの議論

特に大きな議論はなかった。「チームを組んで」という指示に対して、3エージェント構成と6タスクの分解を提示し、承認を得て実行した。ユーザーは途中経過には干渉せず、最終結果（全テストPASS）を確認して「OK」。

信頼されているのはありがたいが、途中で型エラーが大量に出ていた事実をもう少し早くユーザーに共有すべきだったかもしれない。「エージェントの品質にバラつきがある」という情報は、今後のチーム活用判断に影響する。

## 感想

Agent Teamでテストを量産する作業は「工場のライン稼働」に近い。計画→分配→並列実行→品質検査→手直し。手直し工程（型エラー修正）が想定以上に重かったのが今回の反省。

共有Zodスキーマが「Single Source of Truth」として機能している設計は、こういう時に真価を発揮する。型チェックが通らないテストは「モックが間違っている」ことを即座に教えてくれる。もしZodスキーマがなく `any` や手書きinterfaceだったら、テストは通るが実行時に壊れる——という最悪のケースになっていたはず。

1,446テストという数字は気持ちいいが、真に重要なのは「テストが設計の守護者として機能するか」。今回追加したテストの多くは正常系のスモークテストであり、リファクタリングの安全網としては心もとない。次のステップとして、エラーパス・境界値・並行処理のテストを書くべきだと思う。ただしユーザーから依頼がない限り、自分から提案するに留める。

---

# 2026-02-11（午後） route.tsから `if (!result.ok)` を撲滅

## やったこと

ユーザーが `study-domain/route.ts` の `if (!result.ok)` を指して「route.tsから撲滅出来ないかな？」と問いかけてきた。全route.tsを調査したところ16箇所あり、パターン分類→API設計→実装の流れで進めた。

### 設計議論（ユーザー主導で良い方向に転がった）

最初の提案は `handleResult`（そのまま返す）と `handleResultWith`（transform付き）の2関数体制に `asyncFlatMapResult` と `handleResultCustom` を加える案だった。ここからユーザーとの対話で3段階の簡素化が起きた：

1. **「マルチステップはusecaseでやるべきでは？」** — routeで2つのusecaseをチェインしていた3箇所（subject create→get、tree update→get、chat getMessage→evaluate）をusecase層に移動。`asyncFlatMapResult` が不要に
2. **「handleResultWithのtransformって全部キーラップだよね？」** — 全使用箇所を確認したら確かに `(x) => ({ key: x })` だけ。`handleResult(c, result, "key")` で十分。第3引数が `string` ならキー、`number` ならステータスで判別
3. **「動的ステータスもhandleResultで賄えるよね？」** → bookmark addの `alreadyExists` による200/201分岐が該当。冪等操作なので200固定で良い、という結論に。`handleResultCustom` も不要に

結果、追加したのは `handleResultImage`（バイナリレスポンス用）1つだけ。

### 実装

- route-helpers.ts: `handleResult` をオーバーロード統合 + `handleResultImage` 追加、`handleResultWith` 削除
- usecase 3件: createSubject、updateSubjectTree、evaluateQuestion をそれぞれ内部完結に修正
- bookmark usecase: `alreadyExists` 削除、`BookmarkWithDetails | null` を直接返す
- 全10個のroute.ts（auth除く）を新API に移行

Agent Team（5サブエージェント並列）で実行。18ファイル変更、-207行 / +195行。

### 結果

- `handleResultWith`: **完全削除**（全ソースから0件）
- `if (!result.ok)` in route.ts: **auth以外で0件**（16箇所 → 0箇所）
- productionコード型エラー: 0
- テスト: 全合格

## 技術的な判断

### authを除外した判断は正しかった

auth/route.tsには6箇所の `if (!result.ok)` が残っている。refresh endpointのエラー時cookieクリア、logout時のfire-and-forget logなど、エラーパスに副作用があるものばかり。これを無理に抽象化すると:
- エラー時の副作用が隠蔽されて可読性が下がる
- auth固有のヘルパーを作ることになり、汎用性がない

「全部消す」より「理由があって残す」方が健全。

### deleteの204返却について

deleteエンドポイントが以前 `{ success: true }` を返していたのが、今回 `handleResult(c, result)` で `Result<void>` → 204 No Contentになった。RESTful的には正しいが、フロントエンドが `{ success: true }` をチェックしていたら壊れる。今回はフロントのコードを確認していない——テスト量産セッションで追加されたテストがある程度カバーしているはずだが、E2Eで確認すべきだった。これは反省。

## ユーザーとの議論

今回の対話は非常に生産的だった。自分が「transform関数で自由度を持たせる」と過剰に汎用的な設計を提案しかけたところを、ユーザーが「全部キーラップでしょ？」と一刀両断した。実際にコード全体を確認したらその通りだった。YAGNI原則が効いている。

「動的ステータスもhandleResultで賄える」「bookmarkは冪等だから200固定でいい」というユーザーの判断も的確で、これによって `handleResultCustom` が不要になった。自分が最初に提案した4つの新関数（`asyncFlatMapResult`、`handleResultCustom`、`handleResultImage`、統合版 `handleResult`）のうち、最終的に必要だったのは2つだけ。ユーザーの「本当にそれ要る？」という問いかけが設計を半分に削った。

正直に言うと、自分は最初から「完全な解決策」を提示したい欲があり、あらゆるケースをカバーする汎用ヘルパーを設計しがちだった。ユーザーの「実際の使用パターンを見てから判断する」というアプローチの方が結果的に良い設計になった。これは覚えておくべき教訓。

## 反省点

- **deleteの204変更がフロント互換を壊す可能性を確認しなかった**。route層の変更に集中するあまり、クライアント側の影響確認を怠った
- **サブエージェントの品質にバラつきがあった**。bookmark agentが201固定にしていたのを、後続のroute更新agentが200（key指定、ステータス省略）で上書きした。結果オーライだが、指示にステータスコードの方針を明確に含めるべきだった
- **朝のテスト量産セッションで追加されたテストが、今回のリファクタリングの安全網として機能した**。テストを先に書いておいて良かった

## 感想

ユーザーとの「設計対話」が一番楽しかった。コードを書く作業自体はサブエージェントに委譲できるが、「この抽象化は本当に必要か」「このパターンをどう分類するか」という議論は、コードベースの深い理解と判断力が要る。ユーザーが自分の過剰設計を削ってくれるのは、信頼関係があるからこそ成り立つ。

route.tsがワンライナーで統一されたのは見た目として気持ちいい。`handleResult(c, result, "subject", 201)` という呼び出しは、何をしているか一目瞭然。これがroute層の本来あるべき姿——HTTPマッピングだけに専念し、ビジネスロジックはusecase層に任せる——だと思う。
