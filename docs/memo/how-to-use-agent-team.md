# Agent Team活用ガイド

過去の開発日記（2026-01-19〜2026-02-07）を振り返り、Agent Team機能があればもっと良くできた場面を分析した。

## 結論: 実装は直列、レビューは並列

2026-02-06のチーム実験で得られた知見:
- 複数エージェントが同じファイルを編集するとHMRエラーや競合が発生する
- 単純なタスクはチーム運用のオーバーヘッドの方が大きい
- **分析・レビューフェーズの並列化が最も効果的**

これを踏まえた上で、チームが活きるパターンを整理する。

---

## パターン1: 実装+継続的検証チーム

**頻度**: ほぼ毎セッション | **効果**: 最大

### 問題
実装完了を報告した後のブラウザテストでバグが大量発覚するパターンが繰り返されている。

| 日付 | 何が起きたか |
|------|------------|
| 01/20 | Phase1-4実装後にdevサーバー起動→9件のバグ発覚 |
| 01/25 | ブラウザテストで0件セッション問題発見 |
| 02/01 | API 500エラー（マイグレーション未適用） |
| 02/02 | 検索URLが全てundefined、ブックマークの遷移先が間違い |
| 02/05 | ノート作成ボタンが「何も起きない」（Zodスキーマ不整合） |

### チーム構成
```
Team Lead（実装者）
  ├── QA Agent: コード変更のたびに型チェック・テスト・curl確認を実行
  └── Browser Agent: Playwright/Chrome MCPでスモークテスト
```

### ポイント
- 実装者はコードを書くことに集中
- QAエージェントが変更を検知して即座にフィードバック
- ブラウザ確認は画像を含むためコンテキストを圧迫する → 専用エージェントに分離

---

## パターン2: 並列コードレビュー

**頻度**: 10+セッション | **効果**: 高

### 問題
レビューサイクル（実装→Explore→修正→Codex→修正→再レビュー）が直列で時間がかかる。

### 日記の事例
- 01/24: セキュリティレビューを段階的に実施（Explore→Codex→ペネトレーション→統合レビュー）
- 02/01: 設計ドキュメントだけでレビューサイクルが3回転
- 02/06: チーム実験でPdM/UXリサーチャー/FEエンジニア/BEエンジニアが並列レビュー → セキュリティ問題とUX問題を同時発見

### チーム構成
```
Team Lead
  ├── Explore Reviewer: コード構造・設計整合性の観点
  ├── Security Reviewer: 認証・認可・入力バリデーションの観点
  └── Codex Reviewer: バグ・エッジケース・パフォーマンスの観点
```

### ポイント
- 3つの視点を同時に走らせ、結果を統合
- 02/01で「サブエージェントは実装詳細に強く、Codexは設計との整合性に強い」と分析済み
- 02/06で実際にチームレビューを試してBEエンジニントがIDOR脆弱性を発見 → 視点の違うレビュアーが同時に動くことで網羅性が上がる

---

## パターン3: 独立機能の並列実装

**頻度**: 5+セッション | **効果**: 高

### 問題
独立した機能を一つずつ直列で実装している。

### 日記の事例
- 02/02: グローバル検索・ブックマーク・続きから学習の3機能を順番に実装
- 01/25: モバイルバック・品質スタンプ・フォルダクリック等の独立したUI修正を順番に対応

### チーム構成
```
Team Lead（統合・レビュー）
  ├── Feature A Agent: 検索機能（バックエンド+フロントエンド）
  ├── Feature B Agent: ブックマーク機能（バックエンド+フロントエンド）
  └── Feature C Agent: 続きから学習機能（バックエンド+フロントエンド）
```

### ポイント
- 各エージェントが機能のフルスタック（API+UI）を担当
- **ファイルが被らないことが前提**（02/06の教訓）
- 共有コンポーネントへの変更が必要な場合はTeam Leadが調整

---

## パターン4: 大規模実装のコンテキスト分散

**頻度**: 3セッション | **効果**: 中〜高

### 問題
大きな実装でコンテキストウィンドウが枯渇し、セッション中に2回切れた。

### 日記の事例
- 02/01（v2.1実装）: 「大規模実装だったため、セッション中に2回コンテキストが切れた」
- 01/20: Phase1-4の一気通貫実装でバグ多発

### チーム構成
```
Team Lead（全体設計・統合）
  ├── Phase 1 Agent: DBスキーマ変更
  ├── Phase 2 Agent: CRUD API
  ├── Phase 3 Agent: ツリー操作+CSVインポート
  └── Phase 4 Agent: フロントエンド更新
```

### ポイント
- 各エージェントが自分のフェーズのコンテキストだけを保持
- 依存関係がある場合はPhase 1→2→3と直列、独立部分は並列
- Team Leadは全体像を把握し、各エージェントには必要最低限の情報を渡す

---

## パターン5: デバッグの並列仮説検証

**頻度**: 2-3セッション | **効果**: 中

### 問題
誤った仮説で修正を重ねて時間を浪費。

### 日記の事例
- 02/05: SSEストリーミングバグをパフォーマンス問題と誤診 → Markdown再パース最適化やスクロール修正を3回実施 → 本当の原因はReact 18のバッチング+mutableクロージャによるテキスト消失

### チーム構成
```
Team Lead（仮説整理・判定）
  ├── Hypothesis A Agent: パフォーマンス問題の調査
  ├── Hypothesis B Agent: データフロー・状態管理の調査
  └── Browser Agent: 実際の挙動をキャプチャして証拠収集
```

### ポイント
- 複数の仮説を同時に検証し、証拠が揃ったものから対応
- 「3回間違った修正をした」を「1回で正しい原因にたどり着く」に変える

---

## パターン6: スキーマ・型の横断整合チーム

**頻度**: 3+セッション | **効果**: 中

### 問題
共有パッケージに寄せるべきスキーマがフロントエンド/バックエンドに散在。一つずつ直しても別の箇所で同じ問題を作ってしまう。

### 日記の事例
- 02/02: 「野良スキーマ」の統合作業。同じセッション内で同じミスを繰り返す

### チーム構成
```
Team Lead
  ├── Auditor Agent: 全コードベースをスキャンして野良スキーマをリストアップ
  ├── Migrator Agent: リストに基づいてsharedパッケージに移動
  └── Type Checker Agent: 移動後のimport解決・型チェック
```

---

## 使い分けの判断基準

| 条件 | チーム利用 | 単独作業 |
|------|-----------|---------|
| 独立した機能が3つ以上 | o | |
| レビュー（セキュリティ+設計+コード） | o | |
| ブラウザ確認が多い | o（コンテキスト節約） | |
| 大規模実装（コンテキスト切れリスク） | o | |
| 単一ファイルの修正 | | o |
| 依存関係が強い直列タスク | | o |
| 5分で終わる作業 | | o（オーバーヘッドの方が大きい） |

## 注意点（02/06の教訓）

- **同一ファイルの同時編集を避ける**: HMRエラーや競合の原因になる
- **チーム運用のオーバーヘッドを軽視しない**: タスク作成・メッセージング・統合のコストがある
- **実装は直列が安全**: レビュー・分析・調査の並列化から始めるのが現実的
