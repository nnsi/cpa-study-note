# 開発ルール詳細

CLAUDE.mdから切り出した詳細ルール。

## 動作確認の徹底

- **書いたら即検証**: 機能実装後は必ず `curl` または Playwright MCP で動作確認する
- **「動くはず」を信じない**: 型エラーがなくても動作確認するまで完了と言わない
- **End-to-Endで確認**: 「APIが動く」「UIが表示される」ではなく「ユーザーが機能を使える」かを確認
- **curlとブラウザ両方で確認**: curlで動いてもブラウザで動くとは限らない（CORS、Cookie、認証の組み合わせ）
- **現実的なデータサイズでテスト**: 小さなテストデータだけでなく、数MBの画像など実際のユースケースを想定

## APIログ

- **構造化ログ**: 全環境でJSON形式のログを `console.log/warn/error` で出力（`shared/lib/logger.ts`）
- **requestId**: 全ログにリクエスト単位のIDが付与される。1リクエスト内のログを追跡可能
- **ログの使い方**: Route層で `c.get("logger").child({ feature: "xxx" })` を取得し、UseCase層にdeps経由で渡す
- **`console.*` を直接使わない**: 新規コードでは必ず `logger.error/warn/info/debug` を使う
- **実装指針**: `docs/memo/logging-guide.md` を参照

## UI変更時のチェック

- **導線を確認**: 「この画面に来る導線」と「この画面から出る導線」の両方を確認
- **既存フローへの影響**: 追加した機能が既存のフローとどう噛み合うかを考える

## 品質管理

- **型エラーはゼロ**: 「既存のエラーだから」で済ませない
- **型アサーションを避ける**: `as T` より Zodバリデーションや `res.json<T>()` で型を確定させる
- **型アサーションが必要と思ったら設計を疑う**: 型を見直せばアサーションなしで解決できることが多い
- **「仕方ない」と思ったら自問する**: 本当に仕方ないのか？別の方法はないか？
- **仮実装は即報告**: コメントに「一旦」「TODO」「方法が必要」等があれば要確認リストに入れる
- **チェックリストを形骸化させない**: チェックが入っていないタスクは本当に未完了
- **探索結果を鵜呑みにしない**: エージェントの結果は「本当に問題か」を自分で判断してからTodoに入れる
- **反省点として認識したら即修正**: 「後で直す」は放置の言い訳。リリースブロッカーかどうか判断する

## 見積もりの精度

- **「大規模だからスキップ」と言う前に**: 実際の変更ファイル数・行数を確認する
- **既存実装の設計意図を理解する**: 「リフレッシュトークンテーブル＝セッション管理」のように、既存コードが持つ役割を把握する
- **実績ある構成を優先**: 同様の実装が他プロジェクトにあるなら、まずそれを確認して合わせる

## セキュリティ

- **プロンプトインジェクション対策はデフォルト**: AIチャット機能では最初からシステムプロンプトの先頭にセキュリティ指示を配置
- **環境変数は「漏れない構造」**: 「漏れても大丈夫」ではなく、本番に漏れた時の影響を最優先で考える
- **入力バリデーションは明示的に**: 文字列長、ファイル形式、配列サイズをZodで制限
- **複数視点でレビュー**: Exploreエージェント + Codex + ペネトレーションテストの組み合わせ

## 設計思考

- **追加機能で問題を回避しようとしていないか**: 検索やブックマークで「5クリック問題」を回避するより、メインの導線を改善する方が本質的
- **ユーザーのメンタルモデルを優先**: 「学習タブ」をクリックする人は学習したい、編集したいわけではない
- **シンプルな解決策を最初に検討**: 「タブを追加」「メニューを作成」の前に「リンクを1つ置く」で済まないか考える
- **計画ファイルはdocs/配下に出力**: `.claude/plans/`は一時的、永続的な設計ドキュメントは`docs/`に置く
- **既存資産を活用**: 新APIを作る前に、既存APIで実現できないか確認する

## コード探索

LSPツールを活用し、grepより正確な探索を行う。

- **定義元の特定は `goToDefinition`**: grepで関数名を検索するとre-exportやエイリアスに惑わされる。LSPなら型情報を辿って正確な定義元に到達できる
- **影響範囲の調査は `findReferences`**: 変数・関数の変更前に全参照箇所を確認する。grepでは文字列の一致しか見ないが、LSPは意味的な参照を返す
- **ファイル構造の把握は `documentSymbol`**: exportされたスキーマ、関数、型の一覧を取得。ファイルを全部読まなくても構造が分かる
- **ワークスペース横断検索は `workspaceSymbol`**: モノレポ全体から特定のシンボルを名前で検索
- **型情報の確認は `hover`**: 推論された型や関数シグネチャをその場で確認。`Read`でファイルを開くより速い

### grepが適している場面

- 文字列リテラル、コメント、設定値の検索（LSPはこれらをシンボルとして扱わない）
- 正規表現パターンでの横断検索
- ファイルパスやURL、エラーメッセージの検索

## サブエージェント活用

- **出力が大きいツールは委譲**: Playwright MCPなど画像を含む結果はサブエージェントに任せてコンテキストを節約
- **進捗確認は能動的に**: サブエージェントの完了通知を待つだけでなく、`TaskOutput`や`Read`で状態を確認
- **依頼は最後まで確認**: 「AとB両方」と言われたら両方実行する
- **インターフェースを厳密に指定**: サブエージェントに委譲する際は、レスポンス形式、型定義、設計ルール（Route→UseCase→Repository）を明示的に伝える
- **並列実行は依存関係を整理してから**: 依存のないタスクを先に特定し、同時に投げる

## 既知の落とし穴

以下は過去の開発で実際に発生した問題。同じミスを繰り返さないこと。

| 問題 | 原因 | 対策 |
|------|------|------|
| `Headers`オブジェクトがスプレッドで空になる | `{...headers}` は `Headers` クラスに効かない | `Object.fromEntries(headers.entries())` を使う |
| 大きな配列のスプレッドでスタックオーバーフロー | `String.fromCharCode(...hugeArray)` | チャンク処理（32KB単位など）で分割 |
| `credentials: 'include'` と `*` CORSが共存不可 | ブラウザのセキュリティポリシー | 動的にオリジンを返す |
| AIがJSONを ` ```json ``` ` で囲んで返す | LLMの出力フォーマットは不安定 | パース前にコードブロックを除去 |
| 開発モード認証バイパスでトークンフローが検証不能 | フロントエンドがAPIを経由しない | 開発用エンドポイントでも本番と同じフローを通す |
| セッション作成時に0件セッションが残る | 「作成」と「最初のメッセージ」が分離 | 最初のメッセージ送信時にセッション作成 |
| SQLiteマイグレーションでカラムが消える | テーブル再作成時に既存カラムを含め忘れ | CREATE TABLE文に全カラムを明示的に列挙 |
| dev-loginで外部キー制約違反 | 存在しないユーザーIDでトークン保存 | ユーザーが存在しない場合は自動作成 |
| IaC管理のD1を`wrangler d1 delete`で削除 | Terraform管理を確認せず直接操作 | `infra/*.tf`を確認し、IaC管理ならTerraform経由で操作 |
| CIでマイグレーション衝突 | `--file`で直接SQLを実行し`d1_migrations`に履歴が残らない | `wrangler d1 migrations apply`を使うか、履歴テーブルも含めて初期化 |
| wrangler.tomlにdatabase_id固定値 | GitHub Actionsで置換されるプレースホルダーを上書き | `YOUR_STAGING_DATABASE_ID`等のプレースホルダーを維持 |
| D1でBEGIN TRANSACTIONエラー | D1はSQL形式のトランザクションをサポートしない | `createNoTransactionRunner`を使うか、`db.batch()`で原子性を確保 |
| 生SQLでタイムスタンプ比較がマッチしない | Drizzle `mode: "timestamp"` は秒単位、JSは`getTime()`でミリ秒 | Drizzleクエリビルダーを使うか、`Math.floor(ts / 1000)`で変換 |
| `form_input`でReactの状態が更新されない | DOMの値を直接設定してもReactのonChangeは発火しない | `type`アクションを使うか、JavaScriptで直接操作 |
| Codexがシンタックスエラーを誤検出 | PowerShell経由でUTF-8日本語コメントが文字化け | 型チェックとテストが通っていればそちらを信頼 |
| Hono RPCがあるのに独自fetch実装 | 「raw bodyが必要」という思い込み | JSONで`{ content: string }`を送れば良い。一貫性を保つ |
| デフォルト値ロジックがDBと不整合 | `DEFAULT_STUDY_DOMAIN_ID`とDBの実際のIDが違う | フロントエンドから明示的にIDを渡す設計の方が堅牢 |
