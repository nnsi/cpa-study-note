# AI協働開発を4万行スケールさせるアーキテクチャと運用の仕組み

「AIに毎回同じ説明をするのが面倒」「書いてくれたコードの構成がバラバラ」——AI協働開発でこんな悩みを持っていないだろうか。

この記事では、2週間以上にわたってAI（Claude）と協働開発を続け、約4万行のTypeScriptコードベースを構築した経験から、**毎回詳細な指示を出さなくても、AIが一貫したアーキテクチャでコードを書き続けられる仕組み**を紹介する。

:::details コードベースの内訳（cloc計測）
| カテゴリ | 行数 |
|---------|-----|
| API ビジネスロジック | 9,800行 |
| Web アプリケーション | 15,000行 |
| API ユニットテスト | 14,100行 |
| API E2Eテスト | 1,700行 |
| E2E（Playwright） | 330行 |
| Web ユニットテスト | 1,600行 |
| 共有パッケージ（型・スキーマ） | 1,500行 |
| **TypeScript 合計** | **約44,000行** |

※ 設計ドキュメント・日記（Markdown）が約13,000行、DBマイグレーション（SQL）が約2,500行、合計で約68,000行
:::

先に正直に言っておくと、「毎回の指示が不要」になる代わりに「事前の仕込み」は必要になる。ただ、その仕込みは人間のチーム開発でも有効なプラクティスであり、AI協働に限らず価値がある。

## TL;DR

1. **AI生成と相性の良いアーキテクチャを選ぶ** - クリーンアーキテクチャ × 関数型 × Result型
2. **CLAUDE.mdでルールを明文化** - 毎回読み込ませることで一貫性を担保
3. **/docs/に設計ドキュメントを集約** - AIが自律的に判断できる情報を構造化
4. **AIに日記を書かせる** - 振り返りから「落とし穴」を抽出してルールにフィードバック

---

## 前提：AI生成と相性の良いアーキテクチャを選ぶ

AI協働開発で最も重要なのは、**AIが「既存コードを見て同じように書いて」で正しく書ける構造**を作ること。そのために以下のアーキテクチャを採用した。

### クリーンアーキテクチャ（Route → UseCase → Repository）

```
features/
└── topic/
    ├── route.ts      # HTTPエンドポイント定義
    ├── usecase.ts    # ビジネスロジック
    ├── repository.ts # データアクセス
    └── index.ts      # エクスポート
```

**なぜAIと相性が良いか：**

- 各層の責務が明確 → 「Repositoryを書いて」で何を書くべきか迷わない
- 依存方向が一方向（Route → UseCase → Repository）→ AIが勝手に逆方向の依存を作らない
- 既存の`chat/`フォルダを見せれば、同じ構成で`topic/`を作れる

### 関数型スタイル（クラス不使用）

```typescript
// ❌ クラスベース - 継承階層をAIが見落としやすい
class TopicService extends BaseService {
  constructor(private repo: TopicRepository) { super() }
  async createTopic(data: CreateTopicInput) { ... }
}

// ✅ 関数ベース - 入力→出力が明確
export const createTopic = async (
  deps: { repo: TopicRepository },
  input: CreateTopicInput
): Promise<Result<Topic, CreateTopicError>> => {
  // ...
}
```

**なぜAIと相性が良いか：**

- 継承階層を理解する必要がない
- 入力→出力が型シグネチャで明確
- 副作用がdeps経由で明示される → AIが見落としにくい
- テストが書きやすい → depsを差し替えるだけでモックが完結する

```typescript
// テスト時はdepsを差し替えるだけ
const mockRepo = {
  findById: async () => ({ id: "1", name: "test" }),
  createSession: async (input) => ({ id: "new", ...input }),
}
const result = await createSession({ repo: mockRepo }, "user1", "topic1")
```

クラスベースだと`jest.mock()`やDIコンテナの設定が必要になるが、関数型なら引数で渡すだけ。AIがテストを書く際にも「この関数のdepsにモックを渡せばいい」と判断しやすい。

### Result型によるエラーハンドリング

```typescript
// 型定義
type Result<T, E> = { ok: true; value: T } | { ok: false; error: E }

// 使用例
export const createSession = async (
  deps: Dependencies,
  userId: string,
  topicId: string
): Promise<Result<Session, "TOPIC_NOT_FOUND" | "DB_ERROR">> => {
  const topic = await deps.repo.findById(topicId)
  if (!topic) {
    return { ok: false, error: "TOPIC_NOT_FOUND" }
  }
  const session = await deps.repo.createSession({ userId, topicId })
  return { ok: true, value: session }
}

// 呼び出し側 - エラー処理を忘れるとコンパイルエラー
const result = await createSession(deps, userId, topicId)
if (!result.ok) {
  return c.json({ error: result.error }, 404)
}
return c.json({ session: result.value }, 201)
```

**なぜAIと相性が良いか：**

- 例外フローを追う必要がない（try-catchの入れ子地獄を避けられる）
- 型で縛られているので`if (!result.ok)`を書き忘れるとコンパイルエラー
- AIが「ここでエラー処理が必要」と判断しやすい

### Package by Feature

```
apps/api/src/features/
├── auth/      # 認証機能
├── chat/      # チャット機能
├── topic/     # トピック機能
├── note/      # ノート機能
└── image/     # 画像機能
```

**なぜAIと相性が良いか：**

- 1機能に関するファイルが1フォルダに集約 → コンテキストとして渡しやすい
- 「`chat/`フォルダを参考に`bookmark/`機能を作って」が通じる
- 機能間の境界が明確で、AIが勝手に機能を跨いだ依存を作りにくい

**コンテキストウィンドウ対策としても有効：**

コードベースが大きくなると、全ファイルをAIのコンテキストに入れることは不可能になる。Package by Featureなら「`bookmark/`フォルダだけ渡せば、その機能に必要な情報が揃う」。関連ファイルが散らばっている構成だと、AIに何を渡すべきか人間が判断しなければならない。

### Hono RPCによるフロントエンド型連携

バックエンドとフロントエンドで型を共有する仕組みも、AI協働で重要。

```typescript
// バックエンド: route.ts のエクスポート
export type AppType = ReturnType<typeof createApp>

// フロントエンド: api-client.ts
import type { AppType } from "@cpa-study/api"
export const api = hc<AppType>(import.meta.env.VITE_API_URL)

// フロントエンド: 使用時（自動補完が効く）
const res = await api.api.chat.sessions[":sessionId"].messages.$get({
  param: { sessionId },
})
```

**なぜAI協働で有効か：**

- APIの型を変更すると、フロントエンドで型エラーが出る → AIが「フロントも直さなきゃ」と気づく
- `$get`、`$post`などのメソッドが型で絞られる → 間違ったHTTPメソッドを使えない
- レスポンスの型も推論される → AIが戻り値の構造を誤解しない

tRPCに似たDXを、Honoの軽量さで実現できる。

---

## 仕組み①：CLAUDE.md - ルールを明文化して毎回読ませる

プロジェクトルートに`CLAUDE.md`を置き、開発ルールを明文化している。Claude Codeはこのファイルを自動的に読み込む。

### CLAUDE.mdの構成要素

#### 1. アーキテクチャルール

```markdown
## レイヤー遵守

- バックエンドは `Route → UseCase → Repository` の依存方向を守る
- 単純なCRUDでも UseCase を経由する（「妥協」しない）
- 新しいルートを作る時は、同様の既存ルートがどう構成されているか先に確認する
```

「妥協しない」と明記することで、AIが「これは簡単だからRepositoryを直接呼んでいいかな」という判断をしなくなる。

#### 2. 品質基準

```markdown
## 品質管理

- 型エラーはゼロ: 「既存のエラーだから」で済ませない
- 型アサーションを避ける: `as T` より Zodバリデーションで型を確定させる
- 型アサーションが必要と思ったら設計を疑う: 型を見直せばアサーションなしで解決できることが多い
```

「型アサーションが必要と思ったら設計を疑う」のような**メタルール**が重要。AIが安易な解決策に逃げることを防ぐ。

#### 3. 既知の落とし穴テーブル

```markdown
## 既知の落とし穴

| 問題 | 原因 | 対策 |
|------|------|------|
| `Headers`オブジェクトがスプレッドで空になる | `{...headers}` は `Headers` クラスに効かない | `Object.fromEntries(headers.entries())` を使う |
| D1でBEGIN TRANSACTIONエラー | D1はSQL形式のトランザクションをサポートしない | `db.batch()`で原子性を確保 |
| AIがJSONを ```json``` で囲んで返す | LLMの出力フォーマットは不安定 | パース前にコードブロックを除去 |
```

これが**最も効果的な仕組み**。一度踏んだ問題を明文化しておくと、AIは同じミスを繰り返さない。開発を進めながらこのテーブルを育てていく。

#### 4. 開発スキルの定義

```markdown
## 開発用スキル

| スキル | 説明 |
|--------|------|
| `/hono-feature` | Hono APIのFeatureモジュール作成（DI + Hono RPC対応） |
| `/react-feature` | React Featureモジュール作成（3層分離 + Hono RPC + SSE対応） |
| `/check-types` | TypeScript型チェックとESLintを実行 |
```

「`/hono-feature`で新機能を作って」と言えば、AIがどの構成で作るべきかを理解している状態を作る。

各スキルは `.claude/skills/<name>/SKILL.md` に詳細な手順とテンプレートを持っている：

```markdown
# /hono-feature の SKILL.md（抜粋）

## 生成するファイル構成

features/<name>/
├── route.ts       # Honoルート定義
├── usecase.ts     # ビジネスロジック（純粋関数）
├── repository.ts  # DB操作（Drizzle）
├── index.ts       # createXxxFeature ファクトリ
└── *.test.ts      # 各層のテスト

## route.ts のテンプレート

export const createXxxFeature = (env: Env, db: Db) => {
  const repo = createXxxRepository(db)
  const deps = { repo }

  return new Hono<{ Bindings: Env; Variables: Variables }>()
    .get("/", async (c) => {
      const result = await listXxx(deps)
      if (!result.ok) return c.json({ error: result.error }, 500)
      return c.json({ items: result.value })
    })
}
```

このレベルまで具体化しておくと、「`/hono-feature`でbookmark機能作って」だけで正しい構成のコードが生成される。

---

## 仕組み②：/docs/ - AIが自律判断できる設計ドキュメント

設計ドキュメント、タスクリスト、フィードバックをすべて`/docs/`配下に配置している。

### ディレクトリ構成

```
docs/
├── plan/
│   ├── summary.md      # 全体サマリ
│   ├── backend.md      # バックエンド設計
│   └── frontend.md     # フロントエンド設計
├── require.md          # 要件定義
└── diary/              # AIの振り返り日記
    ├── CLAUDE.md       # 日記のルール
    └── 2025-01-31.md   # 日付別の日記
```

### 設計ドキュメントの書き方

AIが自律的に判断できるよう、以下の要素を含める：

```markdown
## Phase 0（MVP）

### 成功基準
- [ ] ユーザーがトピックを選択してチャットを開始できる
- [ ] AIの回答がストリーミングで表示される
- [ ] 会話履歴が保存される

### タスク
1. チャットセッションのCRUD API作成
2. メッセージ送信・取得API作成
3. SSEによるストリーミング実装

### リスクと対策
| リスク | 対策 |
|--------|------|
| D1のコネクション制限 | コネクションプーリングの検討 |
| SSEのタイムアウト | Cloudflare Workersの制限を確認 |
```

**ポイント：**

- **成功基準をチェックリスト形式で書く** → AIが「何をもって完了か」を判断できる
- **タスクを明示** → 「次に何をすべきか」をAIが自律的に判断できる
- **リスクと対策を事前に書く** → AIが実装時に考慮すべき点を認識できる

---

## 仕組み③：/docs/diary/ - AIに振り返りを書かせる

**これが最もユニークな仕組み**。開発セッションの終わりにAIに日記を書かせ、振り返りを蓄積している。

### 日記のルール（docs/diary/CLAUDE.md）

```markdown
## 書く内容

1. 今日やったこと（事実ベース）
2. うまくいったこと
3. うまくいかなかったこと・詰まったこと
4. 学んだこと・気づき
5. 次回への申し送り

## 重要なルール

- ユーザーに迎合しない: 本当に思ったことを正直に書く
- 異論があれば書く: ユーザーの判断に従ったが自分は違う意見だった、という場合は正直に書く
- 自己批判も書く: 「こうすべきだった」「言えなかった」など、反省点も隠さない
```

### 実際の日記の例

```markdown
## 2025-01-31

### やったこと
- メトリクス機能のAPI実装
- フロントエンドのグラフ表示

### うまくいかなかったこと
- 最初、Repositoryから直接データを返す実装をしてしまった
- UseCaseを経由すべきというルールを見落としていた
→ CLAUDE.mdの「単純なCRUDでもUseCaseを経由」を再確認

### 異論
- ユーザーは「権限チェックはミドルウェアで」と言ったが、
  UseCase内でチェックした方がテストしやすいと思う
- ただし今回はユーザーの判断に従った
```

### フィードバックループ

日記で発見した問題は、CLAUDE.mdの「落とし穴テーブル」や開発ルールにフィードバックする：

```
日記で問題発見 → 落とし穴テーブルに追記 → 次回以降は同じミスをしない
```

「異論があれば書く」ルールにより、**AIがレビュアーとしても機能する**。人間が見落とした設計上の問題をAIが指摘してくれる可能性がある。

### 異論が設計変更に繋がった実例

実際に日記の「異論」がルール変更に繋がったケースを紹介する。

**状況：** 学習計画機能で、計画要素を削除したときに「変遷（なぜ変更したか）」を自動記録すべきか議論になった。

**AIの最初の主張：**
> 設計思想として「変遷のreason（なぜ変えたか）はユーザーにしか書けない」から、自動記録だとreasonが空になり、痕跡重視の思想に反する。

**ユーザーの反論：**
> ユーザーは理由を覚えている。毎回変遷もセットで記録させるのは手間を増やしているだけ。理由を書きたければ後から追記できるようにすべき。

**結果：** AIが納得し、「削除時に自動で変遷を作成、reasonは後から追記可能」という設計に変更。日記にはこう書かれた：

```markdown
### 異論
自分の主張は設計思想の「文字通りの遵守」に偏っていて、
実際のユーザー体験を軽視していた。
ユーザーの提案は設計書の精神（痕跡を残す）をより良く実現しつつ、
UXを改善するものだった。
```

この経験はCLAUDE.mdの「設計の異論は黙らず言う」ルールの健全な運用例になった。意見を述べることと、より良い意見に従うことは矛盾しない。

---

## 実際の開発フロー

1. **要件を伝える**
   ```
   「ブックマーク機能を追加したい。トピックをブックマークして、一覧で見れるようにしたい」
   ```

2. **AIが設計ドキュメントを作成**
   - `/docs/plan/`に設計を追記
   - 成功基準、タスク、リスクを明示

3. **実装**
   - AIがCLAUDE.mdのルールに従って実装
   - 既存の`chat/`や`topic/`を参考に同じ構成で作成
   - 「詳細な指示なし」でアーキテクチャが一貫する

4. **日記で振り返り**
   - 問題があれば日記に記録
   - 落とし穴テーブルを更新

5. **次の機能へ**
   - 蓄積されたルールと落とし穴により、次回はさらにスムーズに

---

## 効果と限界

### Before / After

| | Before（仕組み導入前） | After（仕組み導入後） |
|---|---|---|
| **指示** | 「クリーンアーキテクチャで、Route→UseCase→Repositoryの構成で、関数型で、Result型を使って...」と毎回説明 | 「`/hono-feature`でブックマーク機能作って」の一言 |
| **構成の一貫性** | AIが勝手に違う構成で書いて手戻り | 4万行書いても全フォルダが同じ構成 |
| **過去のミス** | 同じ落とし穴に何度もハマる | テーブルを見て回避 |

### 効果

- **毎回の指示量が激減**：Beforeのような説明が不要になった
- **一貫性の維持**：4万行を超えても、どのフォルダを見ても同じ構成になっている
- **過去の失敗を繰り返さない**：落とし穴テーブルにより、同じ問題でハマることがなくなった

### それでもうまくいかなかったこと

仕組みがあっても、すべてがうまくいくわけではない。正直に失敗も書いておく。

**ルールがあっても見落とす：**
日記に何度も「Repositoryを直接呼んでしまった」「UseCaseを経由すべきだった」と書いている。CLAUDE.mdに「単純なCRUDでもUseCaseを経由」と明記しているのに、AIが「これは簡単だから」と判断してショートカットすることがある。

**同じ問題を繰り返す：**
「curlで日本語をPOSTすると文字化けする」という問題を、複数のセッションで繰り返し踏んでいる。落とし穴テーブルに書いても、環境依存の問題はセッションをまたぐと忘れられがち。

**E2Eテストで発見したバグ：**
フロントエンドの`addBookmark`関数が、APIレスポンスを間違ったスキーマでパースしていた。型チェックは通っていたが、実行時にZodバリデーションエラーが発生。E2Eテストを書くまで気づかなかった。仕組みがあっても、実際に動かすテストは必要。

### 限界・注意点

- **初期投資が必要**：CLAUDE.mdや設計ドキュメントの整備には時間がかかる。ただし、この投資は人間のチーム開発でも有効なので、AI協働をやめても無駄にはならない
- **ルールの肥大化**：落とし穴が増えすぎるとCLAUDE.mdが長くなる。定期的な整理が必要
- **AIの判断を過信しない**：日記で「異論」を書かせても、最終判断は人間がすべき
- **向き不向き**：明確な構造を持つWebアプリには向くが、探索的な開発には向かない
- **テストとレビューは別途必要**：この記事はアーキテクチャの一貫性を保つ仕組みであり、品質保証は別の話。型チェック・リント・テストのCI/CDは当然必要だし、AIが書いたコードを人間がレビューするプロセスも省略すべきではない。なお、このプロジェクトではAIにユニットテスト（約17,000行）とE2Eテスト（Playwright）も書かせており、テストコードもこの仕組みで一貫性を保っている
- **チーム開発への適用は未検証**：この記事は「1人の開発者 + AI」の構図。複数人がAIと同時に協働する場合のワークフローは、今後の課題として残っている

---

## 再現するためのポイント

1. **アーキテクチャを先に決める**
   - AIが「同じように書いて」で再現できる構造を選ぶ
   - 関数型 + クリーンアーキテクチャ + Result型の組み合わせがおすすめ

2. **CLAUDE.mdを育てる**
   - 最初は薄くてOK。問題が起きたら落とし穴に追記
   - 「妥協しない」系のメタルールを入れる

3. **設計ドキュメントを構造化する**
   - 成功基準、タスク、リスクを明示
   - AIが「次に何をすべきか」を判断できる情報を揃える

4. **日記を書かせる**
   - 迎合しないルールを明記
   - 日記→落とし穴→ルールのフィードバックループを回す

---

## おわりに

AI協働開発のスケールは、「AIに毎回詳しく説明する」のではなく、「AIが自律的に正しく判断できる仕組みを作る」ことで実現できる。

本質的には、これは人間のチーム開発で行う「コーディング規約」「ADR（Architecture Decision Records）」「ポストモーテム」と同じ。AIとの協働でも、同じ手法が有効だということ。

---

*ちなみに、このコードベースは人間がプロンプトを与え、AIがコードをタイプし、人間がレビュー・判断するという協働で作られた。設計判断は人間、実装はAI、という分担だ。そしてこの記事自体も、同じ協働プロセスで書かれている。*
