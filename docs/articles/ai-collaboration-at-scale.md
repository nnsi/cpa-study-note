# AI協働開発を9万行スケールさせるアーキテクチャと運用の仕組み

2週間以上にわたってAI（Claude）と協働開発を続け、約9万行のTypeScriptコードベースを構築した。特筆すべきは、**毎回詳細な指示を出さなくても、AIが一貫したアーキテクチャでコードを書き続けられる**状態を実現できたこと。

この記事では、AI協働開発をスケールさせるために採用したアーキテクチャと運用の仕組みを紹介する。

## TL;DR

1. **AI生成と相性の良いアーキテクチャを選ぶ** - クリーンアーキテクチャ × 関数型 × Result型
2. **CLAUDE.mdでルールを明文化** - 毎回読み込ませることで一貫性を担保
3. **/docs/に設計ドキュメントを集約** - AIが自律的に判断できる情報を構造化
4. **AIに日記を書かせる** - 振り返りから「落とし穴」を抽出してルールにフィードバック

---

## 前提：AI生成と相性の良いアーキテクチャを選ぶ

AI協働開発で最も重要なのは、**AIが「既存コードを見て同じように書いて」で正しく書ける構造**を作ること。そのために以下のアーキテクチャを採用した。

### クリーンアーキテクチャ（Route → UseCase → Repository）

```
features/
└── topic/
    ├── route.ts      # HTTPエンドポイント定義
    ├── usecase.ts    # ビジネスロジック
    ├── repository.ts # データアクセス
    └── index.ts      # エクスポート
```

**なぜAIと相性が良いか：**

- 各層の責務が明確 → 「Repositoryを書いて」で何を書くべきか迷わない
- 依存方向が一方向（Route → UseCase → Repository）→ AIが勝手に逆方向の依存を作らない
- 既存の`chat/`フォルダを見せれば、同じ構成で`topic/`を作れる

### 関数型スタイル（クラス不使用）

```typescript
// ❌ クラスベース - 継承階層をAIが見落としやすい
class TopicService extends BaseService {
  constructor(private repo: TopicRepository) { super() }
  async createTopic(data: CreateTopicInput) { ... }
}

// ✅ 関数ベース - 入力→出力が明確
export const createTopic = async (
  deps: { repo: TopicRepository },
  input: CreateTopicInput
): Promise<Result<Topic, CreateTopicError>> => {
  // ...
}
```

**なぜAIと相性が良いか：**

- 継承階層を理解する必要がない
- 入力→出力が型シグネチャで明確
- 副作用がdeps経由で明示される → AIが見落としにくい
- テストが書きやすい → depsを差し替えるだけでモックが完結する

```typescript
// テスト時はdepsを差し替えるだけ
const mockRepo = {
  findById: async () => ({ id: "1", name: "test" }),
  createSession: async (input) => ({ id: "new", ...input }),
}
const result = await createSession({ repo: mockRepo }, "user1", "topic1")
```

クラスベースだと`jest.mock()`やDIコンテナの設定が必要になるが、関数型なら引数で渡すだけ。AIがテストを書く際にも「この関数のdepsにモックを渡せばいい」と判断しやすい。

### Result型によるエラーハンドリング

```typescript
// 型定義
type Result<T, E> = { ok: true; value: T } | { ok: false; error: E }

// 使用例
export const createSession = async (
  deps: Dependencies,
  userId: string,
  topicId: string
): Promise<Result<Session, "TOPIC_NOT_FOUND" | "DB_ERROR">> => {
  const topic = await deps.repo.findById(topicId)
  if (!topic) {
    return { ok: false, error: "TOPIC_NOT_FOUND" }
  }
  const session = await deps.repo.createSession({ userId, topicId })
  return { ok: true, value: session }
}

// 呼び出し側 - エラー処理を忘れるとコンパイルエラー
const result = await createSession(deps, userId, topicId)
if (!result.ok) {
  return c.json({ error: result.error }, 404)
}
return c.json({ session: result.value }, 201)
```

**なぜAIと相性が良いか：**

- 例外フローを追う必要がない（try-catchの入れ子地獄を避けられる）
- 型で縛られているので`if (!result.ok)`を書き忘れるとコンパイルエラー
- AIが「ここでエラー処理が必要」と判断しやすい

### Package by Feature

```
apps/api/src/features/
├── auth/      # 認証機能
├── chat/      # チャット機能
├── topic/     # トピック機能
├── note/      # ノート機能
└── image/     # 画像機能
```

**なぜAIと相性が良いか：**

- 1機能に関するファイルが1フォルダに集約 → コンテキストとして渡しやすい
- 「`chat/`フォルダを参考に`bookmark/`機能を作って」が通じる
- 機能間の境界が明確で、AIが勝手に機能を跨いだ依存を作りにくい

---

## 仕組み①：CLAUDE.md - ルールを明文化して毎回読ませる

プロジェクトルートに`CLAUDE.md`を置き、開発ルールを明文化している。Claude Codeはこのファイルを自動的に読み込む。

### CLAUDE.mdの構成要素

#### 1. アーキテクチャルール

```markdown
## レイヤー遵守

- バックエンドは `Route → UseCase → Repository` の依存方向を守る
- 単純なCRUDでも UseCase を経由する（「妥協」しない）
- 新しいルートを作る時は、同様の既存ルートがどう構成されているか先に確認する
```

「妥協しない」と明記することで、AIが「これは簡単だからRepositoryを直接呼んでいいかな」という判断をしなくなる。

#### 2. 品質基準

```markdown
## 品質管理

- 型エラーはゼロ: 「既存のエラーだから」で済ませない
- 型アサーションを避ける: `as T` より Zodバリデーションで型を確定させる
- 型アサーションが必要と思ったら設計を疑う: 型を見直せばアサーションなしで解決できることが多い
```

「型アサーションが必要と思ったら設計を疑う」のような**メタルール**が重要。AIが安易な解決策に逃げることを防ぐ。

#### 3. 既知の落とし穴テーブル

```markdown
## 既知の落とし穴

| 問題 | 原因 | 対策 |
|------|------|------|
| `Headers`オブジェクトがスプレッドで空になる | `{...headers}` は `Headers` クラスに効かない | `Object.fromEntries(headers.entries())` を使う |
| D1でBEGIN TRANSACTIONエラー | D1はSQL形式のトランザクションをサポートしない | `db.batch()`で原子性を確保 |
| AIがJSONを ```json``` で囲んで返す | LLMの出力フォーマットは不安定 | パース前にコードブロックを除去 |
```

これが**最も効果的な仕組み**。一度踏んだ問題を明文化しておくと、AIは同じミスを繰り返さない。開発を進めながらこのテーブルを育てていく。

#### 4. 開発スキルの定義

```markdown
## 開発用スキル

| スキル | 説明 |
|--------|------|
| `/hono-feature` | Hono APIのFeatureモジュール作成（DI + Hono RPC対応） |
| `/react-feature` | React Featureモジュール作成（3層分離 + Hono RPC + SSE対応） |
| `/check-types` | TypeScript型チェックとESLintを実行 |
```

「`/hono-feature`で新機能を作って」と言えば、AIがどの構成で作るべきかを理解している状態を作る。

---

## 仕組み②：/docs/ - AIが自律判断できる設計ドキュメント

設計ドキュメント、タスクリスト、フィードバックをすべて`/docs/`配下に配置している。

### ディレクトリ構成

```
docs/
├── plan/
│   ├── summary.md      # 全体サマリ
│   ├── backend.md      # バックエンド設計
│   └── frontend.md     # フロントエンド設計
├── require.md          # 要件定義
└── diary/              # AIの振り返り日記
    ├── CLAUDE.md       # 日記のルール
    └── 2025-01-31.md   # 日付別の日記
```

### 設計ドキュメントの書き方

AIが自律的に判断できるよう、以下の要素を含める：

```markdown
## Phase 0（MVP）

### 成功基準
- [ ] ユーザーがトピックを選択してチャットを開始できる
- [ ] AIの回答がストリーミングで表示される
- [ ] 会話履歴が保存される

### タスク
1. チャットセッションのCRUD API作成
2. メッセージ送信・取得API作成
3. SSEによるストリーミング実装

### リスクと対策
| リスク | 対策 |
|--------|------|
| D1のコネクション制限 | コネクションプーリングの検討 |
| SSEのタイムアウト | Cloudflare Workersの制限を確認 |
```

**ポイント：**

- **成功基準をチェックリスト形式で書く** → AIが「何をもって完了か」を判断できる
- **タスクを明示** → 「次に何をすべきか」をAIが自律的に判断できる
- **リスクと対策を事前に書く** → AIが実装時に考慮すべき点を認識できる

---

## 仕組み③：/docs/diary/ - AIに振り返りを書かせる

**これが最もユニークな仕組み**。開発セッションの終わりにAIに日記を書かせ、振り返りを蓄積している。

### 日記のルール（docs/diary/CLAUDE.md）

```markdown
## 書く内容

1. 今日やったこと（事実ベース）
2. うまくいったこと
3. うまくいかなかったこと・詰まったこと
4. 学んだこと・気づき
5. 次回への申し送り

## 重要なルール

- ユーザーに迎合しない: 本当に思ったことを正直に書く
- 異論があれば書く: ユーザーの判断に従ったが自分は違う意見だった、という場合は正直に書く
- 自己批判も書く: 「こうすべきだった」「言えなかった」など、反省点も隠さない
```

### 実際の日記の例

```markdown
## 2025-01-31

### やったこと
- メトリクス機能のAPI実装
- フロントエンドのグラフ表示

### うまくいかなかったこと
- 最初、Repositoryから直接データを返す実装をしてしまった
- UseCaseを経由すべきというルールを見落としていた
→ CLAUDE.mdの「単純なCRUDでもUseCaseを経由」を再確認

### 異論
- ユーザーは「権限チェックはミドルウェアで」と言ったが、
  UseCase内でチェックした方がテストしやすいと思う
- ただし今回はユーザーの判断に従った
```

### フィードバックループ

日記で発見した問題は、CLAUDE.mdの「落とし穴テーブル」や開発ルールにフィードバックする：

```
日記で問題発見 → 落とし穴テーブルに追記 → 次回以降は同じミスをしない
```

「異論があれば書く」ルールにより、**AIがレビュアーとしても機能する**。人間が見落とした設計上の問題をAIが指摘してくれる可能性がある。

---

## 実際の開発フロー

1. **要件を伝える**
   ```
   「ブックマーク機能を追加したい。トピックをブックマークして、一覧で見れるようにしたい」
   ```

2. **AIが設計ドキュメントを作成**
   - `/docs/plan/`に設計を追記
   - 成功基準、タスク、リスクを明示

3. **実装**
   - AIがCLAUDE.mdのルールに従って実装
   - 既存の`chat/`や`topic/`を参考に同じ構成で作成
   - 「詳細な指示なし」でアーキテクチャが一貫する

4. **日記で振り返り**
   - 問題があれば日記に記録
   - 落とし穴テーブルを更新

5. **次の機能へ**
   - 蓄積されたルールと落とし穴により、次回はさらにスムーズに

---

## 効果と限界

### 効果

- **毎回の指示量が激減**：最初は「クリーンアーキテクチャで、Route→UseCase→Repositoryの構成で...」と説明していたが、今は「`/hono-feature`でブックマーク機能作って」で済む
- **一貫性の維持**：9万行を超えても、どのフォルダを見ても同じ構成になっている
- **過去の失敗を繰り返さない**：落とし穴テーブルにより、同じ問題でハマることがなくなった

### 限界・注意点

- **初期投資が必要**：CLAUDE.mdや設計ドキュメントの整備には時間がかかる
- **ルールの肥大化**：落とし穴が増えすぎるとCLAUDE.mdが長くなる。定期的な整理が必要
- **AIの判断を過信しない**：日記で「異論」を書かせても、最終判断は人間がすべき
- **向き不向き**：明確な構造を持つWebアプリには向くが、探索的な開発には向かない

---

## 再現するためのポイント

1. **アーキテクチャを先に決める**
   - AIが「同じように書いて」で再現できる構造を選ぶ
   - 関数型 + クリーンアーキテクチャ + Result型の組み合わせがおすすめ

2. **CLAUDE.mdを育てる**
   - 最初は薄くてOK。問題が起きたら落とし穴に追記
   - 「妥協しない」系のメタルールを入れる

3. **設計ドキュメントを構造化する**
   - 成功基準、タスク、リスクを明示
   - AIが「次に何をすべきか」を判断できる情報を揃える

4. **日記を書かせる**
   - 迎合しないルールを明記
   - 日記→落とし穴→ルールのフィードバックループを回す

---

## おわりに

AI協働開発のスケールは、「AIに毎回詳しく説明する」のではなく、「AIが自律的に正しく判断できる仕組みを作る」ことで実現できる。

本質的には、これは人間のチーム開発で行う「コーディング規約」「ADR（Architecture Decision Records）」「ポストモーテム」と同じ。AIとの協働でも、同じ手法が有効だということ。

---

*このコードベース自体が100% AI生成であり、この記事を書いたのもAI（Claude）です。*
