---
name: pre-check
description: 実装前のチェックを行う。見積もり精度向上、既存資産の確認、設計意図の理解。使用場面: (1) 新機能の実装開始前、(2) 「スキップ」判断をする前、(3) 大きな変更を行う前。トリガー: "実装前チェック", "事前確認", "/pre-check"
---

# 実装前チェック

実装を始める前に、以下を確認する。「大規模だからスキップ」という判断ミスを防ぐ。

---

## 1. 既存資産の確認

### 同様の実装が既にあるか

```
確認すべきこと:
- このプロジェクト内に似た機能があるか
- ユーザーの他プロジェクトに実績ある構成があるか
- 使えるライブラリ/ユーティリティが既にあるか
```

**実績ある構成があるなら、まずそれを確認して合わせる。** 独自設計は後から指摘される可能性が高い。

### スキル一覧の確認

実装タスクに関連するスキルがあるか、`.claude/skills/` を確認する。

```bash
ls .claude/skills/
```

「できない」と判断する前に、使えるスキルがないか確認すること。

---

## 2. 見積もりの精度向上

### 「大規模変更だからスキップ」と言う前に

以下を具体的に確認する:

1. **変更が必要なファイル数**
   ```
   - 新規作成: ○ファイル
   - 修正: ○ファイル
   ```

2. **依存するパッケージの追加**
   ```
   - 新規: ○パッケージ
   - バージョン変更: ○パッケージ
   ```

3. **既存コードへの影響範囲**
   ```
   - 型変更による影響: ○箇所
   - インターフェース変更: ○箇所
   ```

### 実際にやってみる

見積もりに自信がない場合は、小さく試してみる。

```
例: 「ライブラリ追加が必要で大変」と思ったら
→ 実際にパッケージを追加してimportしてみる
→ 「意外と1ファイルで完結した」となることが多い
```

---

## 3. 既存実装の設計意図を理解する

### 「このコードは何のためにあるか」

コードの存在理由を理解してから変更を判断する。

```
例: refreshTokensテーブル
- 表面的理解: 「リフレッシュトークンを保存するテーブル」
- 深い理解: 「デバイス単位のセッション管理。ログイン時に作成、ログアウトで削除。各デバイス独立」

→ 「セッション管理機能を追加」というタスクに対して
- 表面的理解: 「新しいテーブルが必要、大規模変更」
- 深い理解: 「既に実現済み、変更不要」
```

### 確認方法

1. 関連するテーブル/型の定義を読む
2. その型を使っている箇所を追う
3. 作成・更新・削除のタイミングを確認

---

## 4. チェックリスト

実装を始める前に以下を確認:

- [ ] 似た機能が既にプロジェクト内にないか確認した
- [ ] 使えるスキルがないか `.claude/skills/` を確認した
- [ ] 変更ファイル数を具体的に見積もった
- [ ] 既存コードの設計意図を理解した
- [ ] 「スキップ」判断をする場合、実際の変更量を確認した

---

## 5. 報告フォーマット

```
## 事前確認結果

### 既存資産
- 似た実装: [あり/なし] - [詳細]
- 関連スキル: [あり/なし] - [スキル名]

### 見積もり
- 新規ファイル: ○件
- 修正ファイル: ○件
- 新規パッケージ: ○件
- 想定工数: [小/中/大]

### 設計意図の理解
- [関連コードの役割の説明]

### 判断
- [実装する/スキップする/確認が必要]
- 理由: [具体的な根拠]
```
